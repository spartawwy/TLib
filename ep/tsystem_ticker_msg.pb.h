// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TLib/ep/tsystem_ticker_msg.proto

#ifndef PROTOBUF_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto__INCLUDED
#define PROTOBUF_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "TLib/core/tsystem_time.pb.h"
#include "TLib/ep/tsystem_ecp_msg.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

class TickHeader;
class BookData;
class BookData_BidAskLevel;
class PrintData;
class PreTradeData;
class DaySummaryData;
class QuoteRequestData;

enum PrintData_DataType {
  PrintData_DataType_LAST_PRINT = 0,
  PrintData_DataType_FILTER_MID = 1
};
bool PrintData_DataType_IsValid(int value);
const PrintData_DataType PrintData_DataType_DataType_MIN = PrintData_DataType_LAST_PRINT;
const PrintData_DataType PrintData_DataType_DataType_MAX = PrintData_DataType_FILTER_MID;
const int PrintData_DataType_DataType_ARRAYSIZE = PrintData_DataType_DataType_MAX + 1;

enum QuoteRequestData_QuoteStatus {
  QuoteRequestData_QuoteStatus_NO_REPLY = 0,
  QuoteRequestData_QuoteStatus_PENDING = 1,
  QuoteRequestData_QuoteStatus_CANCEL = 2,
  QuoteRequestData_QuoteStatus_FILLED = 3,
  QuoteRequestData_QuoteStatus_EXPIRE = 4
};
bool QuoteRequestData_QuoteStatus_IsValid(int value);
const QuoteRequestData_QuoteStatus QuoteRequestData_QuoteStatus_QuoteStatus_MIN = QuoteRequestData_QuoteStatus_NO_REPLY;
const QuoteRequestData_QuoteStatus QuoteRequestData_QuoteStatus_QuoteStatus_MAX = QuoteRequestData_QuoteStatus_EXPIRE;
const int QuoteRequestData_QuoteStatus_QuoteStatus_ARRAYSIZE = QuoteRequestData_QuoteStatus_QuoteStatus_MAX + 1;

// ===================================================================

class TickHeader : public ::google::protobuf::MessageLite {
 public:
  TickHeader();
  virtual ~TickHeader();

  TickHeader(const TickHeader& from);

  inline TickHeader& operator=(const TickHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const TickHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TickHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TickHeader* other);

  // implements Message ----------------------------------------------

  TickHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TickHeader& from);
  void MergeFrom(const TickHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Time timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::Time& timestamp() const;
  inline ::Time* mutable_timestamp();
  inline ::Time* release_timestamp();
  inline void set_allocated_timestamp(::Time* timestamp);

  // optional bool is_valid = 2 [default = true];
  inline bool has_is_valid() const;
  inline void clear_is_valid();
  static const int kIsValidFieldNumber = 2;
  inline bool is_valid() const;
  inline void set_is_valid(bool value);

  // optional int32 contract_id = 3;
  inline bool has_contract_id() const;
  inline void clear_contract_id();
  static const int kContractIdFieldNumber = 3;
  inline ::google::protobuf::int32 contract_id() const;
  inline void set_contract_id(::google::protobuf::int32 value);

  // optional string tick_tag = 4;
  inline bool has_tick_tag() const;
  inline void clear_tick_tag();
  static const int kTickTagFieldNumber = 4;
  inline const ::std::string& tick_tag() const;
  inline void set_tick_tag(const ::std::string& value);
  inline void set_tick_tag(const char* value);
  inline void set_tick_tag(const char* value, size_t size);
  inline ::std::string* mutable_tick_tag();
  inline ::std::string* release_tick_tag();
  inline void set_allocated_tick_tag(::std::string* tick_tag);

  // @@protoc_insertion_point(class_scope:TickHeader)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_is_valid();
  inline void clear_has_is_valid();
  inline void set_has_contract_id();
  inline void clear_has_contract_id();
  inline void set_has_tick_tag();
  inline void clear_has_tick_tag();

  ::Time* timestamp_;
  bool is_valid_;
  ::google::protobuf::int32 contract_id_;
  ::std::string* tick_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static TickHeader* default_instance_;
};
// -------------------------------------------------------------------

class BookData_BidAskLevel : public ::google::protobuf::MessageLite {
 public:
  BookData_BidAskLevel();
  virtual ~BookData_BidAskLevel();

  BookData_BidAskLevel(const BookData_BidAskLevel& from);

  inline BookData_BidAskLevel& operator=(const BookData_BidAskLevel& from) {
    CopyFrom(from);
    return *this;
  }

  static const BookData_BidAskLevel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BookData_BidAskLevel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BookData_BidAskLevel* other);

  // implements Message ----------------------------------------------

  BookData_BidAskLevel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BookData_BidAskLevel& from);
  void MergeFrom(const BookData_BidAskLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double bid_prc = 1 [default = 0];
  inline bool has_bid_prc() const;
  inline void clear_bid_prc();
  static const int kBidPrcFieldNumber = 1;
  inline double bid_prc() const;
  inline void set_bid_prc(double value);

  // optional double ask_prc = 2 [default = 0];
  inline bool has_ask_prc() const;
  inline void clear_ask_prc();
  static const int kAskPrcFieldNumber = 2;
  inline double ask_prc() const;
  inline void set_ask_prc(double value);

  // optional uint32 bid_sze = 3 [default = 0];
  inline bool has_bid_sze() const;
  inline void clear_bid_sze();
  static const int kBidSzeFieldNumber = 3;
  inline ::google::protobuf::uint32 bid_sze() const;
  inline void set_bid_sze(::google::protobuf::uint32 value);

  // optional uint32 ask_sze = 4 [default = 0];
  inline bool has_ask_sze() const;
  inline void clear_ask_sze();
  static const int kAskSzeFieldNumber = 4;
  inline ::google::protobuf::uint32 ask_sze() const;
  inline void set_ask_sze(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BookData.BidAskLevel)
 private:
  inline void set_has_bid_prc();
  inline void clear_has_bid_prc();
  inline void set_has_ask_prc();
  inline void clear_has_ask_prc();
  inline void set_has_bid_sze();
  inline void clear_has_bid_sze();
  inline void set_has_ask_sze();
  inline void clear_has_ask_sze();

  double bid_prc_;
  double ask_prc_;
  ::google::protobuf::uint32 bid_sze_;
  ::google::protobuf::uint32 ask_sze_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static BookData_BidAskLevel* default_instance_;
};
// -------------------------------------------------------------------

class BookData : public ::google::protobuf::MessageLite {
 public:
  BookData();
  virtual ~BookData();

  BookData(const BookData& from);

  inline BookData& operator=(const BookData& from) {
    CopyFrom(from);
    return *this;
  }

  static const BookData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BookData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BookData* other);

  // implements Message ----------------------------------------------

  BookData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BookData& from);
  void MergeFrom(const BookData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BookData_BidAskLevel BidAskLevel;

  // accessors -------------------------------------------------------

  // required .TickHeader tick_info = 1;
  inline bool has_tick_info() const;
  inline void clear_tick_info();
  static const int kTickInfoFieldNumber = 1;
  inline const ::TickHeader& tick_info() const;
  inline ::TickHeader* mutable_tick_info();
  inline ::TickHeader* release_tick_info();
  inline void set_allocated_tick_info(::TickHeader* tick_info);

  // repeated .BookData.BidAskLevel data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::BookData_BidAskLevel& data(int index) const;
  inline ::BookData_BidAskLevel* mutable_data(int index);
  inline ::BookData_BidAskLevel* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::BookData_BidAskLevel >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::BookData_BidAskLevel >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:BookData)
 private:
  inline void set_has_tick_info();
  inline void clear_has_tick_info();

  ::TickHeader* tick_info_;
  ::google::protobuf::RepeatedPtrField< ::BookData_BidAskLevel > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static BookData* default_instance_;
};
// -------------------------------------------------------------------

class PrintData : public ::google::protobuf::MessageLite {
 public:
  PrintData();
  virtual ~PrintData();

  PrintData(const PrintData& from);

  inline PrintData& operator=(const PrintData& from) {
    CopyFrom(from);
    return *this;
  }

  static const PrintData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PrintData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PrintData* other);

  // implements Message ----------------------------------------------

  PrintData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PrintData& from);
  void MergeFrom(const PrintData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PrintData_DataType DataType;
  static const DataType LAST_PRINT = PrintData_DataType_LAST_PRINT;
  static const DataType FILTER_MID = PrintData_DataType_FILTER_MID;
  static inline bool DataType_IsValid(int value) {
    return PrintData_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    PrintData_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    PrintData_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    PrintData_DataType_DataType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .TickHeader tick_info = 1;
  inline bool has_tick_info() const;
  inline void clear_tick_info();
  static const int kTickInfoFieldNumber = 1;
  inline const ::TickHeader& tick_info() const;
  inline ::TickHeader* mutable_tick_info();
  inline ::TickHeader* release_tick_info();
  inline void set_allocated_tick_info(::TickHeader* tick_info);

  // required double data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline double data() const;
  inline void set_data(double value);

  // optional .PrintData.DataType data_type = 3 [default = LAST_PRINT];
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  inline ::PrintData_DataType data_type() const;
  inline void set_data_type(::PrintData_DataType value);

  // @@protoc_insertion_point(class_scope:PrintData)
 private:
  inline void set_has_tick_info();
  inline void clear_has_tick_info();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_data_type();
  inline void clear_has_data_type();

  ::TickHeader* tick_info_;
  double data_;
  int data_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static PrintData* default_instance_;
};
// -------------------------------------------------------------------

class PreTradeData : public ::google::protobuf::MessageLite {
 public:
  PreTradeData();
  virtual ~PreTradeData();

  PreTradeData(const PreTradeData& from);

  inline PreTradeData& operator=(const PreTradeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const PreTradeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PreTradeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PreTradeData* other);

  // implements Message ----------------------------------------------

  PreTradeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PreTradeData& from);
  void MergeFrom(const PreTradeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TickHeader tick_info = 1;
  inline bool has_tick_info() const;
  inline void clear_tick_info();
  static const int kTickInfoFieldNumber = 1;
  inline const ::TickHeader& tick_info() const;
  inline ::TickHeader* mutable_tick_info();
  inline ::TickHeader* release_tick_info();
  inline void set_allocated_tick_info(::TickHeader* tick_info);

  // required double pre_close_prc = 2;
  inline bool has_pre_close_prc() const;
  inline void clear_pre_close_prc();
  static const int kPreClosePrcFieldNumber = 2;
  inline double pre_close_prc() const;
  inline void set_pre_close_prc(double value);

  // optional double pre_settlment_prc = 3 [default = 0];
  inline bool has_pre_settlment_prc() const;
  inline void clear_pre_settlment_prc();
  static const int kPreSettlmentPrcFieldNumber = 3;
  inline double pre_settlment_prc() const;
  inline void set_pre_settlment_prc(double value);

  // optional double pre_open_interest = 4 [default = 0];
  inline bool has_pre_open_interest() const;
  inline void clear_pre_open_interest();
  static const int kPreOpenInterestFieldNumber = 4;
  inline double pre_open_interest() const;
  inline void set_pre_open_interest(double value);

  // optional double today_upper_limit_prc = 5 [default = 0];
  inline bool has_today_upper_limit_prc() const;
  inline void clear_today_upper_limit_prc();
  static const int kTodayUpperLimitPrcFieldNumber = 5;
  inline double today_upper_limit_prc() const;
  inline void set_today_upper_limit_prc(double value);

  // optional double today_lower_limit_prc = 6 [default = 0];
  inline bool has_today_lower_limit_prc() const;
  inline void clear_today_lower_limit_prc();
  static const int kTodayLowerLimitPrcFieldNumber = 6;
  inline double today_lower_limit_prc() const;
  inline void set_today_lower_limit_prc(double value);

  // @@protoc_insertion_point(class_scope:PreTradeData)
 private:
  inline void set_has_tick_info();
  inline void clear_has_tick_info();
  inline void set_has_pre_close_prc();
  inline void clear_has_pre_close_prc();
  inline void set_has_pre_settlment_prc();
  inline void clear_has_pre_settlment_prc();
  inline void set_has_pre_open_interest();
  inline void clear_has_pre_open_interest();
  inline void set_has_today_upper_limit_prc();
  inline void clear_has_today_upper_limit_prc();
  inline void set_has_today_lower_limit_prc();
  inline void clear_has_today_lower_limit_prc();

  ::TickHeader* tick_info_;
  double pre_close_prc_;
  double pre_settlment_prc_;
  double pre_open_interest_;
  double today_upper_limit_prc_;
  double today_lower_limit_prc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static PreTradeData* default_instance_;
};
// -------------------------------------------------------------------

class DaySummaryData : public ::google::protobuf::MessageLite {
 public:
  DaySummaryData();
  virtual ~DaySummaryData();

  DaySummaryData(const DaySummaryData& from);

  inline DaySummaryData& operator=(const DaySummaryData& from) {
    CopyFrom(from);
    return *this;
  }

  static const DaySummaryData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DaySummaryData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DaySummaryData* other);

  // implements Message ----------------------------------------------

  DaySummaryData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DaySummaryData& from);
  void MergeFrom(const DaySummaryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TickHeader tick_info = 1;
  inline bool has_tick_info() const;
  inline void clear_tick_info();
  static const int kTickInfoFieldNumber = 1;
  inline const ::TickHeader& tick_info() const;
  inline ::TickHeader* mutable_tick_info();
  inline ::TickHeader* release_tick_info();
  inline void set_allocated_tick_info(::TickHeader* tick_info);

  // optional double open_prc = 2 [default = 0];
  inline bool has_open_prc() const;
  inline void clear_open_prc();
  static const int kOpenPrcFieldNumber = 2;
  inline double open_prc() const;
  inline void set_open_prc(double value);

  // optional double high_prc = 3 [default = 0];
  inline bool has_high_prc() const;
  inline void clear_high_prc();
  static const int kHighPrcFieldNumber = 3;
  inline double high_prc() const;
  inline void set_high_prc(double value);

  // optional double low_prc = 4 [default = 0];
  inline bool has_low_prc() const;
  inline void clear_low_prc();
  static const int kLowPrcFieldNumber = 4;
  inline double low_prc() const;
  inline void set_low_prc(double value);

  // optional double close_prc = 5 [default = 0];
  inline bool has_close_prc() const;
  inline void clear_close_prc();
  static const int kClosePrcFieldNumber = 5;
  inline double close_prc() const;
  inline void set_close_prc(double value);

  // optional uint32 volume = 6 [default = 0];
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 6;
  inline ::google::protobuf::uint32 volume() const;
  inline void set_volume(::google::protobuf::uint32 value);

  // optional double avg_prc = 7 [default = 0];
  inline bool has_avg_prc() const;
  inline void clear_avg_prc();
  static const int kAvgPrcFieldNumber = 7;
  inline double avg_prc() const;
  inline void set_avg_prc(double value);

  // optional double turnover = 8 [default = 0];
  inline bool has_turnover() const;
  inline void clear_turnover();
  static const int kTurnoverFieldNumber = 8;
  inline double turnover() const;
  inline void set_turnover(double value);

  // optional double open_interest = 9 [default = 0];
  inline bool has_open_interest() const;
  inline void clear_open_interest();
  static const int kOpenInterestFieldNumber = 9;
  inline double open_interest() const;
  inline void set_open_interest(double value);

  // optional double settlment_prc = 10 [default = 0];
  inline bool has_settlment_prc() const;
  inline void clear_settlment_prc();
  static const int kSettlmentPrcFieldNumber = 10;
  inline double settlment_prc() const;
  inline void set_settlment_prc(double value);

  // @@protoc_insertion_point(class_scope:DaySummaryData)
 private:
  inline void set_has_tick_info();
  inline void clear_has_tick_info();
  inline void set_has_open_prc();
  inline void clear_has_open_prc();
  inline void set_has_high_prc();
  inline void clear_has_high_prc();
  inline void set_has_low_prc();
  inline void clear_has_low_prc();
  inline void set_has_close_prc();
  inline void clear_has_close_prc();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_avg_prc();
  inline void clear_has_avg_prc();
  inline void set_has_turnover();
  inline void clear_has_turnover();
  inline void set_has_open_interest();
  inline void clear_has_open_interest();
  inline void set_has_settlment_prc();
  inline void clear_has_settlment_prc();

  ::TickHeader* tick_info_;
  double open_prc_;
  double high_prc_;
  double low_prc_;
  double close_prc_;
  double avg_prc_;
  double turnover_;
  double open_interest_;
  double settlment_prc_;
  ::google::protobuf::uint32 volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static DaySummaryData* default_instance_;
};
// -------------------------------------------------------------------

class QuoteRequestData : public ::google::protobuf::MessageLite {
 public:
  QuoteRequestData();
  virtual ~QuoteRequestData();

  QuoteRequestData(const QuoteRequestData& from);

  inline QuoteRequestData& operator=(const QuoteRequestData& from) {
    CopyFrom(from);
    return *this;
  }

  static const QuoteRequestData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuoteRequestData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuoteRequestData* other);

  // implements Message ----------------------------------------------

  QuoteRequestData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuoteRequestData& from);
  void MergeFrom(const QuoteRequestData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef QuoteRequestData_QuoteStatus QuoteStatus;
  static const QuoteStatus NO_REPLY = QuoteRequestData_QuoteStatus_NO_REPLY;
  static const QuoteStatus PENDING = QuoteRequestData_QuoteStatus_PENDING;
  static const QuoteStatus CANCEL = QuoteRequestData_QuoteStatus_CANCEL;
  static const QuoteStatus FILLED = QuoteRequestData_QuoteStatus_FILLED;
  static const QuoteStatus EXPIRE = QuoteRequestData_QuoteStatus_EXPIRE;
  static inline bool QuoteStatus_IsValid(int value) {
    return QuoteRequestData_QuoteStatus_IsValid(value);
  }
  static const QuoteStatus QuoteStatus_MIN =
    QuoteRequestData_QuoteStatus_QuoteStatus_MIN;
  static const QuoteStatus QuoteStatus_MAX =
    QuoteRequestData_QuoteStatus_QuoteStatus_MAX;
  static const int QuoteStatus_ARRAYSIZE =
    QuoteRequestData_QuoteStatus_QuoteStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .TickHeader tick_info = 1;
  inline bool has_tick_info() const;
  inline void clear_tick_info();
  static const int kTickInfoFieldNumber = 1;
  inline const ::TickHeader& tick_info() const;
  inline ::TickHeader* mutable_tick_info();
  inline ::TickHeader* release_tick_info();
  inline void set_allocated_tick_info(::TickHeader* tick_info);

  // required string qr_id = 2;
  inline bool has_qr_id() const;
  inline void clear_qr_id();
  static const int kQrIdFieldNumber = 2;
  inline const ::std::string& qr_id() const;
  inline void set_qr_id(const ::std::string& value);
  inline void set_qr_id(const char* value);
  inline void set_qr_id(const char* value, size_t size);
  inline ::std::string* mutable_qr_id();
  inline ::std::string* release_qr_id();
  inline void set_allocated_qr_id(::std::string* qr_id);

  // optional .QuoteRequestData.QuoteStatus status = 3 [default = NO_REPLY];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::QuoteRequestData_QuoteStatus status() const;
  inline void set_status(::QuoteRequestData_QuoteStatus value);

  // optional .BuySell buy_sell = 4 [default = BUY];
  inline bool has_buy_sell() const;
  inline void clear_buy_sell();
  static const int kBuySellFieldNumber = 4;
  inline ::BuySell buy_sell() const;
  inline void set_buy_sell(::BuySell value);

  // optional uint32 quantity = 5 [default = 0];
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 5;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:QuoteRequestData)
 private:
  inline void set_has_tick_info();
  inline void clear_has_tick_info();
  inline void set_has_qr_id();
  inline void clear_has_qr_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_buy_sell();
  inline void clear_has_buy_sell();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::TickHeader* tick_info_;
  ::std::string* qr_id_;
  int status_;
  int buy_sell_;
  ::google::protobuf::uint32 quantity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static QuoteRequestData* default_instance_;
};
// ===================================================================


// ===================================================================

// TickHeader

// required .Time timestamp = 1;
inline bool TickHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TickHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TickHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TickHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::Time::Clear();
  clear_has_timestamp();
}
inline const ::Time& TickHeader::timestamp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return timestamp_ != NULL ? *timestamp_ : *default_instance().timestamp_;
#else
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
#endif
}
inline ::Time* TickHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::Time;
  return timestamp_;
}
inline ::Time* TickHeader::release_timestamp() {
  clear_has_timestamp();
  ::Time* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void TickHeader::set_allocated_timestamp(::Time* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional bool is_valid = 2 [default = true];
inline bool TickHeader::has_is_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TickHeader::set_has_is_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TickHeader::clear_has_is_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TickHeader::clear_is_valid() {
  is_valid_ = true;
  clear_has_is_valid();
}
inline bool TickHeader::is_valid() const {
  return is_valid_;
}
inline void TickHeader::set_is_valid(bool value) {
  set_has_is_valid();
  is_valid_ = value;
}

// optional int32 contract_id = 3;
inline bool TickHeader::has_contract_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TickHeader::set_has_contract_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TickHeader::clear_has_contract_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TickHeader::clear_contract_id() {
  contract_id_ = 0;
  clear_has_contract_id();
}
inline ::google::protobuf::int32 TickHeader::contract_id() const {
  return contract_id_;
}
inline void TickHeader::set_contract_id(::google::protobuf::int32 value) {
  set_has_contract_id();
  contract_id_ = value;
}

// optional string tick_tag = 4;
inline bool TickHeader::has_tick_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TickHeader::set_has_tick_tag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TickHeader::clear_has_tick_tag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TickHeader::clear_tick_tag() {
  if (tick_tag_ != &::google::protobuf::internal::kEmptyString) {
    tick_tag_->clear();
  }
  clear_has_tick_tag();
}
inline const ::std::string& TickHeader::tick_tag() const {
  return *tick_tag_;
}
inline void TickHeader::set_tick_tag(const ::std::string& value) {
  set_has_tick_tag();
  if (tick_tag_ == &::google::protobuf::internal::kEmptyString) {
    tick_tag_ = new ::std::string;
  }
  tick_tag_->assign(value);
}
inline void TickHeader::set_tick_tag(const char* value) {
  set_has_tick_tag();
  if (tick_tag_ == &::google::protobuf::internal::kEmptyString) {
    tick_tag_ = new ::std::string;
  }
  tick_tag_->assign(value);
}
inline void TickHeader::set_tick_tag(const char* value, size_t size) {
  set_has_tick_tag();
  if (tick_tag_ == &::google::protobuf::internal::kEmptyString) {
    tick_tag_ = new ::std::string;
  }
  tick_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TickHeader::mutable_tick_tag() {
  set_has_tick_tag();
  if (tick_tag_ == &::google::protobuf::internal::kEmptyString) {
    tick_tag_ = new ::std::string;
  }
  return tick_tag_;
}
inline ::std::string* TickHeader::release_tick_tag() {
  clear_has_tick_tag();
  if (tick_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tick_tag_;
    tick_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TickHeader::set_allocated_tick_tag(::std::string* tick_tag) {
  if (tick_tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tick_tag_;
  }
  if (tick_tag) {
    set_has_tick_tag();
    tick_tag_ = tick_tag;
  } else {
    clear_has_tick_tag();
    tick_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BookData_BidAskLevel

// optional double bid_prc = 1 [default = 0];
inline bool BookData_BidAskLevel::has_bid_prc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BookData_BidAskLevel::set_has_bid_prc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BookData_BidAskLevel::clear_has_bid_prc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BookData_BidAskLevel::clear_bid_prc() {
  bid_prc_ = 0;
  clear_has_bid_prc();
}
inline double BookData_BidAskLevel::bid_prc() const {
  return bid_prc_;
}
inline void BookData_BidAskLevel::set_bid_prc(double value) {
  set_has_bid_prc();
  bid_prc_ = value;
}

// optional double ask_prc = 2 [default = 0];
inline bool BookData_BidAskLevel::has_ask_prc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BookData_BidAskLevel::set_has_ask_prc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BookData_BidAskLevel::clear_has_ask_prc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BookData_BidAskLevel::clear_ask_prc() {
  ask_prc_ = 0;
  clear_has_ask_prc();
}
inline double BookData_BidAskLevel::ask_prc() const {
  return ask_prc_;
}
inline void BookData_BidAskLevel::set_ask_prc(double value) {
  set_has_ask_prc();
  ask_prc_ = value;
}

// optional uint32 bid_sze = 3 [default = 0];
inline bool BookData_BidAskLevel::has_bid_sze() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BookData_BidAskLevel::set_has_bid_sze() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BookData_BidAskLevel::clear_has_bid_sze() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BookData_BidAskLevel::clear_bid_sze() {
  bid_sze_ = 0u;
  clear_has_bid_sze();
}
inline ::google::protobuf::uint32 BookData_BidAskLevel::bid_sze() const {
  return bid_sze_;
}
inline void BookData_BidAskLevel::set_bid_sze(::google::protobuf::uint32 value) {
  set_has_bid_sze();
  bid_sze_ = value;
}

// optional uint32 ask_sze = 4 [default = 0];
inline bool BookData_BidAskLevel::has_ask_sze() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BookData_BidAskLevel::set_has_ask_sze() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BookData_BidAskLevel::clear_has_ask_sze() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BookData_BidAskLevel::clear_ask_sze() {
  ask_sze_ = 0u;
  clear_has_ask_sze();
}
inline ::google::protobuf::uint32 BookData_BidAskLevel::ask_sze() const {
  return ask_sze_;
}
inline void BookData_BidAskLevel::set_ask_sze(::google::protobuf::uint32 value) {
  set_has_ask_sze();
  ask_sze_ = value;
}

// -------------------------------------------------------------------

// BookData

// required .TickHeader tick_info = 1;
inline bool BookData::has_tick_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BookData::set_has_tick_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BookData::clear_has_tick_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BookData::clear_tick_info() {
  if (tick_info_ != NULL) tick_info_->::TickHeader::Clear();
  clear_has_tick_info();
}
inline const ::TickHeader& BookData::tick_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tick_info_ != NULL ? *tick_info_ : *default_instance().tick_info_;
#else
  return tick_info_ != NULL ? *tick_info_ : *default_instance_->tick_info_;
#endif
}
inline ::TickHeader* BookData::mutable_tick_info() {
  set_has_tick_info();
  if (tick_info_ == NULL) tick_info_ = new ::TickHeader;
  return tick_info_;
}
inline ::TickHeader* BookData::release_tick_info() {
  clear_has_tick_info();
  ::TickHeader* temp = tick_info_;
  tick_info_ = NULL;
  return temp;
}
inline void BookData::set_allocated_tick_info(::TickHeader* tick_info) {
  delete tick_info_;
  tick_info_ = tick_info;
  if (tick_info) {
    set_has_tick_info();
  } else {
    clear_has_tick_info();
  }
}

// repeated .BookData.BidAskLevel data = 2;
inline int BookData::data_size() const {
  return data_.size();
}
inline void BookData::clear_data() {
  data_.Clear();
}
inline const ::BookData_BidAskLevel& BookData::data(int index) const {
  return data_.Get(index);
}
inline ::BookData_BidAskLevel* BookData::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::BookData_BidAskLevel* BookData::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BookData_BidAskLevel >&
BookData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::BookData_BidAskLevel >*
BookData::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// PrintData

// required .TickHeader tick_info = 1;
inline bool PrintData::has_tick_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrintData::set_has_tick_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrintData::clear_has_tick_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrintData::clear_tick_info() {
  if (tick_info_ != NULL) tick_info_->::TickHeader::Clear();
  clear_has_tick_info();
}
inline const ::TickHeader& PrintData::tick_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tick_info_ != NULL ? *tick_info_ : *default_instance().tick_info_;
#else
  return tick_info_ != NULL ? *tick_info_ : *default_instance_->tick_info_;
#endif
}
inline ::TickHeader* PrintData::mutable_tick_info() {
  set_has_tick_info();
  if (tick_info_ == NULL) tick_info_ = new ::TickHeader;
  return tick_info_;
}
inline ::TickHeader* PrintData::release_tick_info() {
  clear_has_tick_info();
  ::TickHeader* temp = tick_info_;
  tick_info_ = NULL;
  return temp;
}
inline void PrintData::set_allocated_tick_info(::TickHeader* tick_info) {
  delete tick_info_;
  tick_info_ = tick_info;
  if (tick_info) {
    set_has_tick_info();
  } else {
    clear_has_tick_info();
  }
}

// required double data = 2;
inline bool PrintData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrintData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrintData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrintData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline double PrintData::data() const {
  return data_;
}
inline void PrintData::set_data(double value) {
  set_has_data();
  data_ = value;
}

// optional .PrintData.DataType data_type = 3 [default = LAST_PRINT];
inline bool PrintData::has_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrintData::set_has_data_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrintData::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrintData::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::PrintData_DataType PrintData::data_type() const {
  return static_cast< ::PrintData_DataType >(data_type_);
}
inline void PrintData::set_data_type(::PrintData_DataType value) {
  assert(::PrintData_DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
}

// -------------------------------------------------------------------

// PreTradeData

// required .TickHeader tick_info = 1;
inline bool PreTradeData::has_tick_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreTradeData::set_has_tick_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreTradeData::clear_has_tick_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreTradeData::clear_tick_info() {
  if (tick_info_ != NULL) tick_info_->::TickHeader::Clear();
  clear_has_tick_info();
}
inline const ::TickHeader& PreTradeData::tick_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tick_info_ != NULL ? *tick_info_ : *default_instance().tick_info_;
#else
  return tick_info_ != NULL ? *tick_info_ : *default_instance_->tick_info_;
#endif
}
inline ::TickHeader* PreTradeData::mutable_tick_info() {
  set_has_tick_info();
  if (tick_info_ == NULL) tick_info_ = new ::TickHeader;
  return tick_info_;
}
inline ::TickHeader* PreTradeData::release_tick_info() {
  clear_has_tick_info();
  ::TickHeader* temp = tick_info_;
  tick_info_ = NULL;
  return temp;
}
inline void PreTradeData::set_allocated_tick_info(::TickHeader* tick_info) {
  delete tick_info_;
  tick_info_ = tick_info;
  if (tick_info) {
    set_has_tick_info();
  } else {
    clear_has_tick_info();
  }
}

// required double pre_close_prc = 2;
inline bool PreTradeData::has_pre_close_prc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreTradeData::set_has_pre_close_prc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreTradeData::clear_has_pre_close_prc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreTradeData::clear_pre_close_prc() {
  pre_close_prc_ = 0;
  clear_has_pre_close_prc();
}
inline double PreTradeData::pre_close_prc() const {
  return pre_close_prc_;
}
inline void PreTradeData::set_pre_close_prc(double value) {
  set_has_pre_close_prc();
  pre_close_prc_ = value;
}

// optional double pre_settlment_prc = 3 [default = 0];
inline bool PreTradeData::has_pre_settlment_prc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreTradeData::set_has_pre_settlment_prc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreTradeData::clear_has_pre_settlment_prc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreTradeData::clear_pre_settlment_prc() {
  pre_settlment_prc_ = 0;
  clear_has_pre_settlment_prc();
}
inline double PreTradeData::pre_settlment_prc() const {
  return pre_settlment_prc_;
}
inline void PreTradeData::set_pre_settlment_prc(double value) {
  set_has_pre_settlment_prc();
  pre_settlment_prc_ = value;
}

// optional double pre_open_interest = 4 [default = 0];
inline bool PreTradeData::has_pre_open_interest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreTradeData::set_has_pre_open_interest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreTradeData::clear_has_pre_open_interest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreTradeData::clear_pre_open_interest() {
  pre_open_interest_ = 0;
  clear_has_pre_open_interest();
}
inline double PreTradeData::pre_open_interest() const {
  return pre_open_interest_;
}
inline void PreTradeData::set_pre_open_interest(double value) {
  set_has_pre_open_interest();
  pre_open_interest_ = value;
}

// optional double today_upper_limit_prc = 5 [default = 0];
inline bool PreTradeData::has_today_upper_limit_prc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PreTradeData::set_has_today_upper_limit_prc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PreTradeData::clear_has_today_upper_limit_prc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PreTradeData::clear_today_upper_limit_prc() {
  today_upper_limit_prc_ = 0;
  clear_has_today_upper_limit_prc();
}
inline double PreTradeData::today_upper_limit_prc() const {
  return today_upper_limit_prc_;
}
inline void PreTradeData::set_today_upper_limit_prc(double value) {
  set_has_today_upper_limit_prc();
  today_upper_limit_prc_ = value;
}

// optional double today_lower_limit_prc = 6 [default = 0];
inline bool PreTradeData::has_today_lower_limit_prc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PreTradeData::set_has_today_lower_limit_prc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PreTradeData::clear_has_today_lower_limit_prc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PreTradeData::clear_today_lower_limit_prc() {
  today_lower_limit_prc_ = 0;
  clear_has_today_lower_limit_prc();
}
inline double PreTradeData::today_lower_limit_prc() const {
  return today_lower_limit_prc_;
}
inline void PreTradeData::set_today_lower_limit_prc(double value) {
  set_has_today_lower_limit_prc();
  today_lower_limit_prc_ = value;
}

// -------------------------------------------------------------------

// DaySummaryData

// required .TickHeader tick_info = 1;
inline bool DaySummaryData::has_tick_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DaySummaryData::set_has_tick_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DaySummaryData::clear_has_tick_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DaySummaryData::clear_tick_info() {
  if (tick_info_ != NULL) tick_info_->::TickHeader::Clear();
  clear_has_tick_info();
}
inline const ::TickHeader& DaySummaryData::tick_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tick_info_ != NULL ? *tick_info_ : *default_instance().tick_info_;
#else
  return tick_info_ != NULL ? *tick_info_ : *default_instance_->tick_info_;
#endif
}
inline ::TickHeader* DaySummaryData::mutable_tick_info() {
  set_has_tick_info();
  if (tick_info_ == NULL) tick_info_ = new ::TickHeader;
  return tick_info_;
}
inline ::TickHeader* DaySummaryData::release_tick_info() {
  clear_has_tick_info();
  ::TickHeader* temp = tick_info_;
  tick_info_ = NULL;
  return temp;
}
inline void DaySummaryData::set_allocated_tick_info(::TickHeader* tick_info) {
  delete tick_info_;
  tick_info_ = tick_info;
  if (tick_info) {
    set_has_tick_info();
  } else {
    clear_has_tick_info();
  }
}

// optional double open_prc = 2 [default = 0];
inline bool DaySummaryData::has_open_prc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DaySummaryData::set_has_open_prc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DaySummaryData::clear_has_open_prc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DaySummaryData::clear_open_prc() {
  open_prc_ = 0;
  clear_has_open_prc();
}
inline double DaySummaryData::open_prc() const {
  return open_prc_;
}
inline void DaySummaryData::set_open_prc(double value) {
  set_has_open_prc();
  open_prc_ = value;
}

// optional double high_prc = 3 [default = 0];
inline bool DaySummaryData::has_high_prc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DaySummaryData::set_has_high_prc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DaySummaryData::clear_has_high_prc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DaySummaryData::clear_high_prc() {
  high_prc_ = 0;
  clear_has_high_prc();
}
inline double DaySummaryData::high_prc() const {
  return high_prc_;
}
inline void DaySummaryData::set_high_prc(double value) {
  set_has_high_prc();
  high_prc_ = value;
}

// optional double low_prc = 4 [default = 0];
inline bool DaySummaryData::has_low_prc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DaySummaryData::set_has_low_prc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DaySummaryData::clear_has_low_prc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DaySummaryData::clear_low_prc() {
  low_prc_ = 0;
  clear_has_low_prc();
}
inline double DaySummaryData::low_prc() const {
  return low_prc_;
}
inline void DaySummaryData::set_low_prc(double value) {
  set_has_low_prc();
  low_prc_ = value;
}

// optional double close_prc = 5 [default = 0];
inline bool DaySummaryData::has_close_prc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DaySummaryData::set_has_close_prc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DaySummaryData::clear_has_close_prc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DaySummaryData::clear_close_prc() {
  close_prc_ = 0;
  clear_has_close_prc();
}
inline double DaySummaryData::close_prc() const {
  return close_prc_;
}
inline void DaySummaryData::set_close_prc(double value) {
  set_has_close_prc();
  close_prc_ = value;
}

// optional uint32 volume = 6 [default = 0];
inline bool DaySummaryData::has_volume() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DaySummaryData::set_has_volume() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DaySummaryData::clear_has_volume() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DaySummaryData::clear_volume() {
  volume_ = 0u;
  clear_has_volume();
}
inline ::google::protobuf::uint32 DaySummaryData::volume() const {
  return volume_;
}
inline void DaySummaryData::set_volume(::google::protobuf::uint32 value) {
  set_has_volume();
  volume_ = value;
}

// optional double avg_prc = 7 [default = 0];
inline bool DaySummaryData::has_avg_prc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DaySummaryData::set_has_avg_prc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DaySummaryData::clear_has_avg_prc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DaySummaryData::clear_avg_prc() {
  avg_prc_ = 0;
  clear_has_avg_prc();
}
inline double DaySummaryData::avg_prc() const {
  return avg_prc_;
}
inline void DaySummaryData::set_avg_prc(double value) {
  set_has_avg_prc();
  avg_prc_ = value;
}

// optional double turnover = 8 [default = 0];
inline bool DaySummaryData::has_turnover() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DaySummaryData::set_has_turnover() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DaySummaryData::clear_has_turnover() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DaySummaryData::clear_turnover() {
  turnover_ = 0;
  clear_has_turnover();
}
inline double DaySummaryData::turnover() const {
  return turnover_;
}
inline void DaySummaryData::set_turnover(double value) {
  set_has_turnover();
  turnover_ = value;
}

// optional double open_interest = 9 [default = 0];
inline bool DaySummaryData::has_open_interest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DaySummaryData::set_has_open_interest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DaySummaryData::clear_has_open_interest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DaySummaryData::clear_open_interest() {
  open_interest_ = 0;
  clear_has_open_interest();
}
inline double DaySummaryData::open_interest() const {
  return open_interest_;
}
inline void DaySummaryData::set_open_interest(double value) {
  set_has_open_interest();
  open_interest_ = value;
}

// optional double settlment_prc = 10 [default = 0];
inline bool DaySummaryData::has_settlment_prc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DaySummaryData::set_has_settlment_prc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DaySummaryData::clear_has_settlment_prc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DaySummaryData::clear_settlment_prc() {
  settlment_prc_ = 0;
  clear_has_settlment_prc();
}
inline double DaySummaryData::settlment_prc() const {
  return settlment_prc_;
}
inline void DaySummaryData::set_settlment_prc(double value) {
  set_has_settlment_prc();
  settlment_prc_ = value;
}

// -------------------------------------------------------------------

// QuoteRequestData

// required .TickHeader tick_info = 1;
inline bool QuoteRequestData::has_tick_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuoteRequestData::set_has_tick_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuoteRequestData::clear_has_tick_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuoteRequestData::clear_tick_info() {
  if (tick_info_ != NULL) tick_info_->::TickHeader::Clear();
  clear_has_tick_info();
}
inline const ::TickHeader& QuoteRequestData::tick_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tick_info_ != NULL ? *tick_info_ : *default_instance().tick_info_;
#else
  return tick_info_ != NULL ? *tick_info_ : *default_instance_->tick_info_;
#endif
}
inline ::TickHeader* QuoteRequestData::mutable_tick_info() {
  set_has_tick_info();
  if (tick_info_ == NULL) tick_info_ = new ::TickHeader;
  return tick_info_;
}
inline ::TickHeader* QuoteRequestData::release_tick_info() {
  clear_has_tick_info();
  ::TickHeader* temp = tick_info_;
  tick_info_ = NULL;
  return temp;
}
inline void QuoteRequestData::set_allocated_tick_info(::TickHeader* tick_info) {
  delete tick_info_;
  tick_info_ = tick_info;
  if (tick_info) {
    set_has_tick_info();
  } else {
    clear_has_tick_info();
  }
}

// required string qr_id = 2;
inline bool QuoteRequestData::has_qr_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuoteRequestData::set_has_qr_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuoteRequestData::clear_has_qr_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuoteRequestData::clear_qr_id() {
  if (qr_id_ != &::google::protobuf::internal::kEmptyString) {
    qr_id_->clear();
  }
  clear_has_qr_id();
}
inline const ::std::string& QuoteRequestData::qr_id() const {
  return *qr_id_;
}
inline void QuoteRequestData::set_qr_id(const ::std::string& value) {
  set_has_qr_id();
  if (qr_id_ == &::google::protobuf::internal::kEmptyString) {
    qr_id_ = new ::std::string;
  }
  qr_id_->assign(value);
}
inline void QuoteRequestData::set_qr_id(const char* value) {
  set_has_qr_id();
  if (qr_id_ == &::google::protobuf::internal::kEmptyString) {
    qr_id_ = new ::std::string;
  }
  qr_id_->assign(value);
}
inline void QuoteRequestData::set_qr_id(const char* value, size_t size) {
  set_has_qr_id();
  if (qr_id_ == &::google::protobuf::internal::kEmptyString) {
    qr_id_ = new ::std::string;
  }
  qr_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuoteRequestData::mutable_qr_id() {
  set_has_qr_id();
  if (qr_id_ == &::google::protobuf::internal::kEmptyString) {
    qr_id_ = new ::std::string;
  }
  return qr_id_;
}
inline ::std::string* QuoteRequestData::release_qr_id() {
  clear_has_qr_id();
  if (qr_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qr_id_;
    qr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuoteRequestData::set_allocated_qr_id(::std::string* qr_id) {
  if (qr_id_ != &::google::protobuf::internal::kEmptyString) {
    delete qr_id_;
  }
  if (qr_id) {
    set_has_qr_id();
    qr_id_ = qr_id;
  } else {
    clear_has_qr_id();
    qr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .QuoteRequestData.QuoteStatus status = 3 [default = NO_REPLY];
inline bool QuoteRequestData::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuoteRequestData::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuoteRequestData::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuoteRequestData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::QuoteRequestData_QuoteStatus QuoteRequestData::status() const {
  return static_cast< ::QuoteRequestData_QuoteStatus >(status_);
}
inline void QuoteRequestData::set_status(::QuoteRequestData_QuoteStatus value) {
  assert(::QuoteRequestData_QuoteStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .BuySell buy_sell = 4 [default = BUY];
inline bool QuoteRequestData::has_buy_sell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuoteRequestData::set_has_buy_sell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuoteRequestData::clear_has_buy_sell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuoteRequestData::clear_buy_sell() {
  buy_sell_ = 0;
  clear_has_buy_sell();
}
inline ::BuySell QuoteRequestData::buy_sell() const {
  return static_cast< ::BuySell >(buy_sell_);
}
inline void QuoteRequestData::set_buy_sell(::BuySell value) {
  assert(::BuySell_IsValid(value));
  set_has_buy_sell();
  buy_sell_ = value;
}

// optional uint32 quantity = 5 [default = 0];
inline bool QuoteRequestData::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuoteRequestData::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuoteRequestData::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuoteRequestData::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 QuoteRequestData::quantity() const {
  return quantity_;
}
inline void QuoteRequestData::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TLib_2fep_2ftsystem_5fticker_5fmsg_2eproto__INCLUDED
