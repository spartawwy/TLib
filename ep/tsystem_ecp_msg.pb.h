// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TLib/ep/tsystem_ecp_msg.proto

#ifndef PROTOBUF_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto__INCLUDED
#define PROTOBUF_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "TLib/core/tsystem_return_code.pb.h"
#include "TLib/core/tsystem_time.pb.h"
#include "TLib/tool/tsystem_rational_number.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

class EcpUserRequest;
class OrderInfo;
class SimpleOrder;
class TwoSideOrder;
class TwoSideOrder_OneSideQuote;
class OrderHeader;
class OrderRequest;
class OrderRequestAck;
class OrderAck;
class OrderFill;

enum EcpUserRequest_Type {
  EcpUserRequest_Type_LOGIN = 0,
  EcpUserRequest_Type_LOGOUT = 1
};
bool EcpUserRequest_Type_IsValid(int value);
const EcpUserRequest_Type EcpUserRequest_Type_Type_MIN = EcpUserRequest_Type_LOGIN;
const EcpUserRequest_Type EcpUserRequest_Type_Type_MAX = EcpUserRequest_Type_LOGOUT;
const int EcpUserRequest_Type_Type_ARRAYSIZE = EcpUserRequest_Type_Type_MAX + 1;

enum OrderInfo_OrderType {
  OrderInfo_OrderType_SIMPLE_ORDER = 0,
  OrderInfo_OrderType_TWO_SIDE_ORDER = 1
};
bool OrderInfo_OrderType_IsValid(int value);
const OrderInfo_OrderType OrderInfo_OrderType_OrderType_MIN = OrderInfo_OrderType_SIMPLE_ORDER;
const OrderInfo_OrderType OrderInfo_OrderType_OrderType_MAX = OrderInfo_OrderType_TWO_SIDE_ORDER;
const int OrderInfo_OrderType_OrderType_ARRAYSIZE = OrderInfo_OrderType_OrderType_MAX + 1;

enum OrderHeader_OrderStatus {
  OrderHeader_OrderStatus_NO_REPLY = 0,
  OrderHeader_OrderStatus_RECEIVED = 1,
  OrderHeader_OrderStatus_FULL_FILL = 2,
  OrderHeader_OrderStatus_PARTIL_FILL = 3,
  OrderHeader_OrderStatus_PENDING = 4,
  OrderHeader_OrderStatus_CANCEL = 5
};
bool OrderHeader_OrderStatus_IsValid(int value);
const OrderHeader_OrderStatus OrderHeader_OrderStatus_OrderStatus_MIN = OrderHeader_OrderStatus_NO_REPLY;
const OrderHeader_OrderStatus OrderHeader_OrderStatus_OrderStatus_MAX = OrderHeader_OrderStatus_CANCEL;
const int OrderHeader_OrderStatus_OrderStatus_ARRAYSIZE = OrderHeader_OrderStatus_OrderStatus_MAX + 1;

enum OrderRequestAck_Type {
  OrderRequestAck_Type_Submit = 0,
  OrderRequestAck_Type_Cancel = 1
};
bool OrderRequestAck_Type_IsValid(int value);
const OrderRequestAck_Type OrderRequestAck_Type_Type_MIN = OrderRequestAck_Type_Submit;
const OrderRequestAck_Type OrderRequestAck_Type_Type_MAX = OrderRequestAck_Type_Cancel;
const int OrderRequestAck_Type_Type_ARRAYSIZE = OrderRequestAck_Type_Type_MAX + 1;

enum BuySell {
  BUY = 0,
  SELL = 1
};
bool BuySell_IsValid(int value);
const BuySell BuySell_MIN = BUY;
const BuySell BuySell_MAX = SELL;
const int BuySell_ARRAYSIZE = BuySell_MAX + 1;

enum OpenClose {
  OPEN = 0,
  CLOSE = 1,
  CLOSE_OVERNIGHT = 2,
  CLOSE_INTRDAY = 3
};
bool OpenClose_IsValid(int value);
const OpenClose OpenClose_MIN = OPEN;
const OpenClose OpenClose_MAX = CLOSE_INTRDAY;
const int OpenClose_ARRAYSIZE = OpenClose_MAX + 1;

enum IOC {
  NONE = 0,
  FOK = 1,
  FAK = 2
};
bool IOC_IsValid(int value);
const IOC IOC_MIN = NONE;
const IOC IOC_MAX = FAK;
const int IOC_ARRAYSIZE = IOC_MAX + 1;

enum Source {
  EXCHANGE = 0,
  COUNTER = 1,
  FAKE = 2
};
bool Source_IsValid(int value);
const Source Source_MIN = EXCHANGE;
const Source Source_MAX = FAKE;
const int Source_ARRAYSIZE = Source_MAX + 1;

enum Mode {
  NORMAL = 0,
  INJECT = 1,
  EXPIRE = 2,
  ADJUST = 3,
  POSITION = 4,
  CASH = 5
};
bool Mode_IsValid(int value);
const Mode Mode_MIN = NORMAL;
const Mode Mode_MAX = CASH;
const int Mode_ARRAYSIZE = Mode_MAX + 1;

enum CombUnComb {
  COMB = 0,
  UNCOMB = 1
};
bool CombUnComb_IsValid(int value);
const CombUnComb CombUnComb_MIN = COMB;
const CombUnComb CombUnComb_MAX = UNCOMB;
const int CombUnComb_ARRAYSIZE = CombUnComb_MAX + 1;

// ===================================================================

class EcpUserRequest : public ::google::protobuf::MessageLite {
 public:
  EcpUserRequest();
  virtual ~EcpUserRequest();

  EcpUserRequest(const EcpUserRequest& from);

  inline EcpUserRequest& operator=(const EcpUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const EcpUserRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EcpUserRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EcpUserRequest* other);

  // implements Message ----------------------------------------------

  EcpUserRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EcpUserRequest& from);
  void MergeFrom(const EcpUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef EcpUserRequest_Type Type;
  static const Type LOGIN = EcpUserRequest_Type_LOGIN;
  static const Type LOGOUT = EcpUserRequest_Type_LOGOUT;
  static inline bool Type_IsValid(int value) {
    return EcpUserRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    EcpUserRequest_Type_Type_MIN;
  static const Type Type_MAX =
    EcpUserRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    EcpUserRequest_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 request_id() const;
  inline void set_request_id(::google::protobuf::uint32 value);

  // required .EcpUserRequest.Type request_type = 2;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 2;
  inline ::EcpUserRequest_Type request_type() const;
  inline void set_request_type(::EcpUserRequest_Type value);

  // required uint32 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 process_id = 4;
  inline bool has_process_id() const;
  inline void clear_process_id();
  static const int kProcessIdFieldNumber = 4;
  inline ::google::protobuf::uint32 process_id() const;
  inline void set_process_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EcpUserRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_process_id();
  inline void clear_has_process_id();

  ::google::protobuf::uint32 request_id_;
  int request_type_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 process_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static EcpUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class OrderInfo : public ::google::protobuf::MessageLite {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderInfo* other);

  // implements Message ----------------------------------------------

  OrderInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef OrderInfo_OrderType OrderType;
  static const OrderType SIMPLE_ORDER = OrderInfo_OrderType_SIMPLE_ORDER;
  static const OrderType TWO_SIDE_ORDER = OrderInfo_OrderType_TWO_SIDE_ORDER;
  static inline bool OrderType_IsValid(int value) {
    return OrderInfo_OrderType_IsValid(value);
  }
  static const OrderType OrderType_MIN =
    OrderInfo_OrderType_OrderType_MIN;
  static const OrderType OrderType_MAX =
    OrderInfo_OrderType_OrderType_MAX;
  static const int OrderType_ARRAYSIZE =
    OrderInfo_OrderType_OrderType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .OrderInfo.OrderType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::OrderInfo_OrderType type() const;
  inline void set_type(::OrderInfo_OrderType value);

  // optional .SimpleOrder simple_order = 2;
  inline bool has_simple_order() const;
  inline void clear_simple_order();
  static const int kSimpleOrderFieldNumber = 2;
  inline const ::SimpleOrder& simple_order() const;
  inline ::SimpleOrder* mutable_simple_order();
  inline ::SimpleOrder* release_simple_order();
  inline void set_allocated_simple_order(::SimpleOrder* simple_order);

  // optional .TwoSideOrder two_side_order = 3;
  inline bool has_two_side_order() const;
  inline void clear_two_side_order();
  static const int kTwoSideOrderFieldNumber = 3;
  inline const ::TwoSideOrder& two_side_order() const;
  inline ::TwoSideOrder* mutable_two_side_order();
  inline ::TwoSideOrder* release_two_side_order();
  inline void set_allocated_two_side_order(::TwoSideOrder* two_side_order);

  // @@protoc_insertion_point(class_scope:OrderInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_simple_order();
  inline void clear_has_simple_order();
  inline void set_has_two_side_order();
  inline void clear_has_two_side_order();

  ::SimpleOrder* simple_order_;
  ::TwoSideOrder* two_side_order_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static OrderInfo* default_instance_;
};
// -------------------------------------------------------------------

class SimpleOrder : public ::google::protobuf::MessageLite {
 public:
  SimpleOrder();
  virtual ~SimpleOrder();

  SimpleOrder(const SimpleOrder& from);

  inline SimpleOrder& operator=(const SimpleOrder& from) {
    CopyFrom(from);
    return *this;
  }

  static const SimpleOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SimpleOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SimpleOrder* other);

  // implements Message ----------------------------------------------

  SimpleOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SimpleOrder& from);
  void MergeFrom(const SimpleOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OpenClose open_close = 1 [default = OPEN];
  inline bool has_open_close() const;
  inline void clear_open_close();
  static const int kOpenCloseFieldNumber = 1;
  inline ::OpenClose open_close() const;
  inline void set_open_close(::OpenClose value);

  // required .BuySell buy_sell = 2;
  inline bool has_buy_sell() const;
  inline void clear_buy_sell();
  static const int kBuySellFieldNumber = 2;
  inline ::BuySell buy_sell() const;
  inline void set_buy_sell(::BuySell value);

  // required uint32 quantity = 3;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);

  // optional .RationalNumber price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline const ::RationalNumber& price() const;
  inline ::RationalNumber* mutable_price();
  inline ::RationalNumber* release_price();
  inline void set_allocated_price(::RationalNumber* price);

  // optional uint32 fill_qty = 5 [default = 0];
  inline bool has_fill_qty() const;
  inline void clear_fill_qty();
  static const int kFillQtyFieldNumber = 5;
  inline ::google::protobuf::uint32 fill_qty() const;
  inline void set_fill_qty(::google::protobuf::uint32 value);

  // optional uint32 cancel_qty = 6 [default = 0];
  inline bool has_cancel_qty() const;
  inline void clear_cancel_qty();
  static const int kCancelQtyFieldNumber = 6;
  inline ::google::protobuf::uint32 cancel_qty() const;
  inline void set_cancel_qty(::google::protobuf::uint32 value);

  // optional .IOC ioc = 7 [default = NONE];
  inline bool has_ioc() const;
  inline void clear_ioc();
  static const int kIocFieldNumber = 7;
  inline ::IOC ioc() const;
  inline void set_ioc(::IOC value);

  // @@protoc_insertion_point(class_scope:SimpleOrder)
 private:
  inline void set_has_open_close();
  inline void clear_has_open_close();
  inline void set_has_buy_sell();
  inline void clear_has_buy_sell();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_fill_qty();
  inline void clear_has_fill_qty();
  inline void set_has_cancel_qty();
  inline void clear_has_cancel_qty();
  inline void set_has_ioc();
  inline void clear_has_ioc();

  int open_close_;
  int buy_sell_;
  ::RationalNumber* price_;
  ::google::protobuf::uint32 quantity_;
  ::google::protobuf::uint32 fill_qty_;
  ::google::protobuf::uint32 cancel_qty_;
  int ioc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static SimpleOrder* default_instance_;
};
// -------------------------------------------------------------------

class TwoSideOrder_OneSideQuote : public ::google::protobuf::MessageLite {
 public:
  TwoSideOrder_OneSideQuote();
  virtual ~TwoSideOrder_OneSideQuote();

  TwoSideOrder_OneSideQuote(const TwoSideOrder_OneSideQuote& from);

  inline TwoSideOrder_OneSideQuote& operator=(const TwoSideOrder_OneSideQuote& from) {
    CopyFrom(from);
    return *this;
  }

  static const TwoSideOrder_OneSideQuote& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TwoSideOrder_OneSideQuote* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TwoSideOrder_OneSideQuote* other);

  // implements Message ----------------------------------------------

  TwoSideOrder_OneSideQuote* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TwoSideOrder_OneSideQuote& from);
  void MergeFrom(const TwoSideOrder_OneSideQuote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OpenClose open_close = 1 [default = OPEN];
  inline bool has_open_close() const;
  inline void clear_open_close();
  static const int kOpenCloseFieldNumber = 1;
  inline ::OpenClose open_close() const;
  inline void set_open_close(::OpenClose value);

  // required uint32 quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);

  // required .RationalNumber price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline const ::RationalNumber& price() const;
  inline ::RationalNumber* mutable_price();
  inline ::RationalNumber* release_price();
  inline void set_allocated_price(::RationalNumber* price);

  // optional uint32 fill_qty = 4;
  inline bool has_fill_qty() const;
  inline void clear_fill_qty();
  static const int kFillQtyFieldNumber = 4;
  inline ::google::protobuf::uint32 fill_qty() const;
  inline void set_fill_qty(::google::protobuf::uint32 value);

  // optional uint32 cancel_qty = 5;
  inline bool has_cancel_qty() const;
  inline void clear_cancel_qty();
  static const int kCancelQtyFieldNumber = 5;
  inline ::google::protobuf::uint32 cancel_qty() const;
  inline void set_cancel_qty(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TwoSideOrder.OneSideQuote)
 private:
  inline void set_has_open_close();
  inline void clear_has_open_close();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_fill_qty();
  inline void clear_has_fill_qty();
  inline void set_has_cancel_qty();
  inline void clear_has_cancel_qty();

  int open_close_;
  ::google::protobuf::uint32 quantity_;
  ::RationalNumber* price_;
  ::google::protobuf::uint32 fill_qty_;
  ::google::protobuf::uint32 cancel_qty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static TwoSideOrder_OneSideQuote* default_instance_;
};
// -------------------------------------------------------------------

class TwoSideOrder : public ::google::protobuf::MessageLite {
 public:
  TwoSideOrder();
  virtual ~TwoSideOrder();

  TwoSideOrder(const TwoSideOrder& from);

  inline TwoSideOrder& operator=(const TwoSideOrder& from) {
    CopyFrom(from);
    return *this;
  }

  static const TwoSideOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TwoSideOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TwoSideOrder* other);

  // implements Message ----------------------------------------------

  TwoSideOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TwoSideOrder& from);
  void MergeFrom(const TwoSideOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TwoSideOrder_OneSideQuote OneSideQuote;

  // accessors -------------------------------------------------------

  // optional .TwoSideOrder.OneSideQuote bid_quote = 2;
  inline bool has_bid_quote() const;
  inline void clear_bid_quote();
  static const int kBidQuoteFieldNumber = 2;
  inline const ::TwoSideOrder_OneSideQuote& bid_quote() const;
  inline ::TwoSideOrder_OneSideQuote* mutable_bid_quote();
  inline ::TwoSideOrder_OneSideQuote* release_bid_quote();
  inline void set_allocated_bid_quote(::TwoSideOrder_OneSideQuote* bid_quote);

  // optional .TwoSideOrder.OneSideQuote ask_quote = 3;
  inline bool has_ask_quote() const;
  inline void clear_ask_quote();
  static const int kAskQuoteFieldNumber = 3;
  inline const ::TwoSideOrder_OneSideQuote& ask_quote() const;
  inline ::TwoSideOrder_OneSideQuote* mutable_ask_quote();
  inline ::TwoSideOrder_OneSideQuote* release_ask_quote();
  inline void set_allocated_ask_quote(::TwoSideOrder_OneSideQuote* ask_quote);

  // @@protoc_insertion_point(class_scope:TwoSideOrder)
 private:
  inline void set_has_bid_quote();
  inline void clear_has_bid_quote();
  inline void set_has_ask_quote();
  inline void clear_has_ask_quote();

  ::TwoSideOrder_OneSideQuote* bid_quote_;
  ::TwoSideOrder_OneSideQuote* ask_quote_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static TwoSideOrder* default_instance_;
};
// -------------------------------------------------------------------

class OrderHeader : public ::google::protobuf::MessageLite {
 public:
  OrderHeader();
  virtual ~OrderHeader();

  OrderHeader(const OrderHeader& from);

  inline OrderHeader& operator=(const OrderHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderHeader* other);

  // implements Message ----------------------------------------------

  OrderHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderHeader& from);
  void MergeFrom(const OrderHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef OrderHeader_OrderStatus OrderStatus;
  static const OrderStatus NO_REPLY = OrderHeader_OrderStatus_NO_REPLY;
  static const OrderStatus RECEIVED = OrderHeader_OrderStatus_RECEIVED;
  static const OrderStatus FULL_FILL = OrderHeader_OrderStatus_FULL_FILL;
  static const OrderStatus PARTIL_FILL = OrderHeader_OrderStatus_PARTIL_FILL;
  static const OrderStatus PENDING = OrderHeader_OrderStatus_PENDING;
  static const OrderStatus CANCEL = OrderHeader_OrderStatus_CANCEL;
  static inline bool OrderStatus_IsValid(int value) {
    return OrderHeader_OrderStatus_IsValid(value);
  }
  static const OrderStatus OrderStatus_MIN =
    OrderHeader_OrderStatus_OrderStatus_MIN;
  static const OrderStatus OrderStatus_MAX =
    OrderHeader_OrderStatus_OrderStatus_MAX;
  static const int OrderStatus_ARRAYSIZE =
    OrderHeader_OrderStatus_OrderStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .Time timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::Time& timestamp() const;
  inline ::Time* mutable_timestamp();
  inline ::Time* release_timestamp();
  inline void set_allocated_timestamp(::Time* timestamp);

  // optional uint32 user_id = 2 [default = 0];
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional uint32 user_ref = 3 [default = 0];
  inline bool has_user_ref() const;
  inline void clear_user_ref();
  static const int kUserRefFieldNumber = 3;
  inline ::google::protobuf::uint32 user_ref() const;
  inline void set_user_ref(::google::protobuf::uint32 value);

  // optional uint32 process_id = 4 [default = 0];
  inline bool has_process_id() const;
  inline void clear_process_id();
  static const int kProcessIdFieldNumber = 4;
  inline ::google::protobuf::uint32 process_id() const;
  inline void set_process_id(::google::protobuf::uint32 value);

  // optional uint32 ecp_oid = 5 [default = 0];
  inline bool has_ecp_oid() const;
  inline void clear_ecp_oid();
  static const int kEcpOidFieldNumber = 5;
  inline ::google::protobuf::uint32 ecp_oid() const;
  inline void set_ecp_oid(::google::protobuf::uint32 value);

  // optional uint32 seq_id = 6 [default = 0];
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 6;
  inline ::google::protobuf::uint32 seq_id() const;
  inline void set_seq_id(::google::protobuf::uint32 value);

  // optional .OrderHeader.OrderStatus status = 7 [default = NO_REPLY];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::OrderHeader_OrderStatus status() const;
  inline void set_status(::OrderHeader_OrderStatus value);

  // optional int32 contract_id = 8;
  inline bool has_contract_id() const;
  inline void clear_contract_id();
  static const int kContractIdFieldNumber = 8;
  inline ::google::protobuf::int32 contract_id() const;
  inline void set_contract_id(::google::protobuf::int32 value);

  // optional string remark = 9;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 9;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional string quote_ref = 10;
  inline bool has_quote_ref() const;
  inline void clear_quote_ref();
  static const int kQuoteRefFieldNumber = 10;
  inline const ::std::string& quote_ref() const;
  inline void set_quote_ref(const ::std::string& value);
  inline void set_quote_ref(const char* value);
  inline void set_quote_ref(const char* value, size_t size);
  inline ::std::string* mutable_quote_ref();
  inline ::std::string* release_quote_ref();
  inline void set_allocated_quote_ref(::std::string* quote_ref);

  // @@protoc_insertion_point(class_scope:OrderHeader)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_ref();
  inline void clear_has_user_ref();
  inline void set_has_process_id();
  inline void clear_has_process_id();
  inline void set_has_ecp_oid();
  inline void clear_has_ecp_oid();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_contract_id();
  inline void clear_has_contract_id();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_quote_ref();
  inline void clear_has_quote_ref();

  ::Time* timestamp_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 user_ref_;
  ::google::protobuf::uint32 process_id_;
  ::google::protobuf::uint32 ecp_oid_;
  ::google::protobuf::uint32 seq_id_;
  int status_;
  ::std::string* remark_;
  ::std::string* quote_ref_;
  ::google::protobuf::int32 contract_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static OrderHeader* default_instance_;
};
// -------------------------------------------------------------------

class OrderRequest : public ::google::protobuf::MessageLite {
 public:
  OrderRequest();
  virtual ~OrderRequest();

  OrderRequest(const OrderRequest& from);

  inline OrderRequest& operator=(const OrderRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderRequest* other);

  // implements Message ----------------------------------------------

  OrderRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderRequest& from);
  void MergeFrom(const OrderRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .OrderHeader order_header = 1;
  inline bool has_order_header() const;
  inline void clear_order_header();
  static const int kOrderHeaderFieldNumber = 1;
  inline const ::OrderHeader& order_header() const;
  inline ::OrderHeader* mutable_order_header();
  inline ::OrderHeader* release_order_header();
  inline void set_allocated_order_header(::OrderHeader* order_header);

  // optional .OrderInfo order_info = 2;
  inline bool has_order_info() const;
  inline void clear_order_info();
  static const int kOrderInfoFieldNumber = 2;
  inline const ::OrderInfo& order_info() const;
  inline ::OrderInfo* mutable_order_info();
  inline ::OrderInfo* release_order_info();
  inline void set_allocated_order_info(::OrderInfo* order_info);

  // optional bool cancel_on_disconnect = 3 [default = true];
  inline bool has_cancel_on_disconnect() const;
  inline void clear_cancel_on_disconnect();
  static const int kCancelOnDisconnectFieldNumber = 3;
  inline bool cancel_on_disconnect() const;
  inline void set_cancel_on_disconnect(bool value);

  // optional int32 time_out = 4 [default = -1];
  inline bool has_time_out() const;
  inline void clear_time_out();
  static const int kTimeOutFieldNumber = 4;
  inline ::google::protobuf::int32 time_out() const;
  inline void set_time_out(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OrderRequest)
 private:
  inline void set_has_order_header();
  inline void clear_has_order_header();
  inline void set_has_order_info();
  inline void clear_has_order_info();
  inline void set_has_cancel_on_disconnect();
  inline void clear_has_cancel_on_disconnect();
  inline void set_has_time_out();
  inline void clear_has_time_out();

  ::OrderHeader* order_header_;
  ::OrderInfo* order_info_;
  bool cancel_on_disconnect_;
  ::google::protobuf::int32 time_out_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static OrderRequest* default_instance_;
};
// -------------------------------------------------------------------

class OrderRequestAck : public ::google::protobuf::MessageLite {
 public:
  OrderRequestAck();
  virtual ~OrderRequestAck();

  OrderRequestAck(const OrderRequestAck& from);

  inline OrderRequestAck& operator=(const OrderRequestAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderRequestAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderRequestAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderRequestAck* other);

  // implements Message ----------------------------------------------

  OrderRequestAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderRequestAck& from);
  void MergeFrom(const OrderRequestAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef OrderRequestAck_Type Type;
  static const Type Submit = OrderRequestAck_Type_Submit;
  static const Type Cancel = OrderRequestAck_Type_Cancel;
  static inline bool Type_IsValid(int value) {
    return OrderRequestAck_Type_IsValid(value);
  }
  static const Type Type_MIN =
    OrderRequestAck_Type_Type_MIN;
  static const Type Type_MAX =
    OrderRequestAck_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    OrderRequestAck_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .ReturnCode return_code = 1;
  inline bool has_return_code() const;
  inline void clear_return_code();
  static const int kReturnCodeFieldNumber = 1;
  inline const ::ReturnCode& return_code() const;
  inline ::ReturnCode* mutable_return_code();
  inline ::ReturnCode* release_return_code();
  inline void set_allocated_return_code(::ReturnCode* return_code);

  // required .OrderHeader order_header = 2;
  inline bool has_order_header() const;
  inline void clear_order_header();
  static const int kOrderHeaderFieldNumber = 2;
  inline const ::OrderHeader& order_header() const;
  inline ::OrderHeader* mutable_order_header();
  inline ::OrderHeader* release_order_header();
  inline void set_allocated_order_header(::OrderHeader* order_header);

  // required .OrderRequestAck.Type request_type = 3;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 3;
  inline ::OrderRequestAck_Type request_type() const;
  inline void set_request_type(::OrderRequestAck_Type value);

  // @@protoc_insertion_point(class_scope:OrderRequestAck)
 private:
  inline void set_has_return_code();
  inline void clear_has_return_code();
  inline void set_has_order_header();
  inline void clear_has_order_header();
  inline void set_has_request_type();
  inline void clear_has_request_type();

  ::ReturnCode* return_code_;
  ::OrderHeader* order_header_;
  int request_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static OrderRequestAck* default_instance_;
};
// -------------------------------------------------------------------

class OrderAck : public ::google::protobuf::MessageLite {
 public:
  OrderAck();
  virtual ~OrderAck();

  OrderAck(const OrderAck& from);

  inline OrderAck& operator=(const OrderAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderAck* other);

  // implements Message ----------------------------------------------

  OrderAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderAck& from);
  void MergeFrom(const OrderAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .OrderHeader order_header = 1;
  inline bool has_order_header() const;
  inline void clear_order_header();
  static const int kOrderHeaderFieldNumber = 1;
  inline const ::OrderHeader& order_header() const;
  inline ::OrderHeader* mutable_order_header();
  inline ::OrderHeader* release_order_header();
  inline void set_allocated_order_header(::OrderHeader* order_header);

  // required .OrderInfo order_info = 2;
  inline bool has_order_info() const;
  inline void clear_order_info();
  static const int kOrderInfoFieldNumber = 2;
  inline const ::OrderInfo& order_info() const;
  inline ::OrderInfo* mutable_order_info();
  inline ::OrderInfo* release_order_info();
  inline void set_allocated_order_info(::OrderInfo* order_info);

  // @@protoc_insertion_point(class_scope:OrderAck)
 private:
  inline void set_has_order_header();
  inline void clear_has_order_header();
  inline void set_has_order_info();
  inline void clear_has_order_info();

  ::OrderHeader* order_header_;
  ::OrderInfo* order_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static OrderAck* default_instance_;
};
// -------------------------------------------------------------------

class OrderFill : public ::google::protobuf::MessageLite {
 public:
  OrderFill();
  virtual ~OrderFill();

  OrderFill(const OrderFill& from);

  inline OrderFill& operator=(const OrderFill& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderFill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderFill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderFill* other);

  // implements Message ----------------------------------------------

  OrderFill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderFill& from);
  void MergeFrom(const OrderFill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Time exec_time = 1;
  inline bool has_exec_time() const;
  inline void clear_exec_time();
  static const int kExecTimeFieldNumber = 1;
  inline const ::Time& exec_time() const;
  inline ::Time* mutable_exec_time();
  inline ::Time* release_exec_time();
  inline void set_allocated_exec_time(::Time* exec_time);

  // required string exec_id = 2;
  inline bool has_exec_id() const;
  inline void clear_exec_id();
  static const int kExecIdFieldNumber = 2;
  inline const ::std::string& exec_id() const;
  inline void set_exec_id(const ::std::string& value);
  inline void set_exec_id(const char* value);
  inline void set_exec_id(const char* value, size_t size);
  inline ::std::string* mutable_exec_id();
  inline ::std::string* release_exec_id();
  inline void set_allocated_exec_id(::std::string* exec_id);

  // optional .OpenClose open_close = 3 [default = OPEN];
  inline bool has_open_close() const;
  inline void clear_open_close();
  static const int kOpenCloseFieldNumber = 3;
  inline ::OpenClose open_close() const;
  inline void set_open_close(::OpenClose value);

  // required .BuySell buy_sell = 4;
  inline bool has_buy_sell() const;
  inline void clear_buy_sell();
  static const int kBuySellFieldNumber = 4;
  inline ::BuySell buy_sell() const;
  inline void set_buy_sell(::BuySell value);

  // required uint32 quantity = 5;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 5;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);

  // required double price = 6;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 6;
  inline double price() const;
  inline void set_price(double value);

  // optional .Source source = 7 [default = EXCHANGE];
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 7;
  inline ::Source source() const;
  inline void set_source(::Source value);

  // optional .Mode mode = 8 [default = NORMAL];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 8;
  inline ::Mode mode() const;
  inline void set_mode(::Mode value);

  // required .OrderHeader order_header = 9;
  inline bool has_order_header() const;
  inline void clear_order_header();
  static const int kOrderHeaderFieldNumber = 9;
  inline const ::OrderHeader& order_header() const;
  inline ::OrderHeader* mutable_order_header();
  inline ::OrderHeader* release_order_header();
  inline void set_allocated_order_header(::OrderHeader* order_header);

  // required uint32 clearing_date = 10;
  inline bool has_clearing_date() const;
  inline void clear_clearing_date();
  static const int kClearingDateFieldNumber = 10;
  inline ::google::protobuf::uint32 clearing_date() const;
  inline void set_clearing_date(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OrderFill)
 private:
  inline void set_has_exec_time();
  inline void clear_has_exec_time();
  inline void set_has_exec_id();
  inline void clear_has_exec_id();
  inline void set_has_open_close();
  inline void clear_has_open_close();
  inline void set_has_buy_sell();
  inline void clear_has_buy_sell();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_order_header();
  inline void clear_has_order_header();
  inline void set_has_clearing_date();
  inline void clear_has_clearing_date();

  ::Time* exec_time_;
  ::std::string* exec_id_;
  int open_close_;
  int buy_sell_;
  double price_;
  ::google::protobuf::uint32 quantity_;
  int source_;
  ::OrderHeader* order_header_;
  int mode_;
  ::google::protobuf::uint32 clearing_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static OrderFill* default_instance_;
};
// ===================================================================


// ===================================================================

// EcpUserRequest

// required uint32 request_id = 1;
inline bool EcpUserRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EcpUserRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EcpUserRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EcpUserRequest::clear_request_id() {
  request_id_ = 0u;
  clear_has_request_id();
}
inline ::google::protobuf::uint32 EcpUserRequest::request_id() const {
  return request_id_;
}
inline void EcpUserRequest::set_request_id(::google::protobuf::uint32 value) {
  set_has_request_id();
  request_id_ = value;
}

// required .EcpUserRequest.Type request_type = 2;
inline bool EcpUserRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EcpUserRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EcpUserRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EcpUserRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::EcpUserRequest_Type EcpUserRequest::request_type() const {
  return static_cast< ::EcpUserRequest_Type >(request_type_);
}
inline void EcpUserRequest::set_request_type(::EcpUserRequest_Type value) {
  assert(::EcpUserRequest_Type_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// required uint32 user_id = 3;
inline bool EcpUserRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EcpUserRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EcpUserRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EcpUserRequest::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 EcpUserRequest::user_id() const {
  return user_id_;
}
inline void EcpUserRequest::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 process_id = 4;
inline bool EcpUserRequest::has_process_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EcpUserRequest::set_has_process_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EcpUserRequest::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EcpUserRequest::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 EcpUserRequest::process_id() const {
  return process_id_;
}
inline void EcpUserRequest::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
}

// -------------------------------------------------------------------

// OrderInfo

// required .OrderInfo.OrderType type = 1;
inline bool OrderInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::OrderInfo_OrderType OrderInfo::type() const {
  return static_cast< ::OrderInfo_OrderType >(type_);
}
inline void OrderInfo::set_type(::OrderInfo_OrderType value) {
  assert(::OrderInfo_OrderType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .SimpleOrder simple_order = 2;
inline bool OrderInfo::has_simple_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfo::set_has_simple_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfo::clear_has_simple_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfo::clear_simple_order() {
  if (simple_order_ != NULL) simple_order_->::SimpleOrder::Clear();
  clear_has_simple_order();
}
inline const ::SimpleOrder& OrderInfo::simple_order() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return simple_order_ != NULL ? *simple_order_ : *default_instance().simple_order_;
#else
  return simple_order_ != NULL ? *simple_order_ : *default_instance_->simple_order_;
#endif
}
inline ::SimpleOrder* OrderInfo::mutable_simple_order() {
  set_has_simple_order();
  if (simple_order_ == NULL) simple_order_ = new ::SimpleOrder;
  return simple_order_;
}
inline ::SimpleOrder* OrderInfo::release_simple_order() {
  clear_has_simple_order();
  ::SimpleOrder* temp = simple_order_;
  simple_order_ = NULL;
  return temp;
}
inline void OrderInfo::set_allocated_simple_order(::SimpleOrder* simple_order) {
  delete simple_order_;
  simple_order_ = simple_order;
  if (simple_order) {
    set_has_simple_order();
  } else {
    clear_has_simple_order();
  }
}

// optional .TwoSideOrder two_side_order = 3;
inline bool OrderInfo::has_two_side_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfo::set_has_two_side_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfo::clear_has_two_side_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfo::clear_two_side_order() {
  if (two_side_order_ != NULL) two_side_order_->::TwoSideOrder::Clear();
  clear_has_two_side_order();
}
inline const ::TwoSideOrder& OrderInfo::two_side_order() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return two_side_order_ != NULL ? *two_side_order_ : *default_instance().two_side_order_;
#else
  return two_side_order_ != NULL ? *two_side_order_ : *default_instance_->two_side_order_;
#endif
}
inline ::TwoSideOrder* OrderInfo::mutable_two_side_order() {
  set_has_two_side_order();
  if (two_side_order_ == NULL) two_side_order_ = new ::TwoSideOrder;
  return two_side_order_;
}
inline ::TwoSideOrder* OrderInfo::release_two_side_order() {
  clear_has_two_side_order();
  ::TwoSideOrder* temp = two_side_order_;
  two_side_order_ = NULL;
  return temp;
}
inline void OrderInfo::set_allocated_two_side_order(::TwoSideOrder* two_side_order) {
  delete two_side_order_;
  two_side_order_ = two_side_order;
  if (two_side_order) {
    set_has_two_side_order();
  } else {
    clear_has_two_side_order();
  }
}

// -------------------------------------------------------------------

// SimpleOrder

// optional .OpenClose open_close = 1 [default = OPEN];
inline bool SimpleOrder::has_open_close() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleOrder::set_has_open_close() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleOrder::clear_has_open_close() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleOrder::clear_open_close() {
  open_close_ = 0;
  clear_has_open_close();
}
inline ::OpenClose SimpleOrder::open_close() const {
  return static_cast< ::OpenClose >(open_close_);
}
inline void SimpleOrder::set_open_close(::OpenClose value) {
  assert(::OpenClose_IsValid(value));
  set_has_open_close();
  open_close_ = value;
}

// required .BuySell buy_sell = 2;
inline bool SimpleOrder::has_buy_sell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimpleOrder::set_has_buy_sell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimpleOrder::clear_has_buy_sell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimpleOrder::clear_buy_sell() {
  buy_sell_ = 0;
  clear_has_buy_sell();
}
inline ::BuySell SimpleOrder::buy_sell() const {
  return static_cast< ::BuySell >(buy_sell_);
}
inline void SimpleOrder::set_buy_sell(::BuySell value) {
  assert(::BuySell_IsValid(value));
  set_has_buy_sell();
  buy_sell_ = value;
}

// required uint32 quantity = 3;
inline bool SimpleOrder::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimpleOrder::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimpleOrder::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimpleOrder::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 SimpleOrder::quantity() const {
  return quantity_;
}
inline void SimpleOrder::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
}

// optional .RationalNumber price = 4;
inline bool SimpleOrder::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimpleOrder::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimpleOrder::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimpleOrder::clear_price() {
  if (price_ != NULL) price_->::RationalNumber::Clear();
  clear_has_price();
}
inline const ::RationalNumber& SimpleOrder::price() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return price_ != NULL ? *price_ : *default_instance().price_;
#else
  return price_ != NULL ? *price_ : *default_instance_->price_;
#endif
}
inline ::RationalNumber* SimpleOrder::mutable_price() {
  set_has_price();
  if (price_ == NULL) price_ = new ::RationalNumber;
  return price_;
}
inline ::RationalNumber* SimpleOrder::release_price() {
  clear_has_price();
  ::RationalNumber* temp = price_;
  price_ = NULL;
  return temp;
}
inline void SimpleOrder::set_allocated_price(::RationalNumber* price) {
  delete price_;
  price_ = price;
  if (price) {
    set_has_price();
  } else {
    clear_has_price();
  }
}

// optional uint32 fill_qty = 5 [default = 0];
inline bool SimpleOrder::has_fill_qty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SimpleOrder::set_has_fill_qty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SimpleOrder::clear_has_fill_qty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SimpleOrder::clear_fill_qty() {
  fill_qty_ = 0u;
  clear_has_fill_qty();
}
inline ::google::protobuf::uint32 SimpleOrder::fill_qty() const {
  return fill_qty_;
}
inline void SimpleOrder::set_fill_qty(::google::protobuf::uint32 value) {
  set_has_fill_qty();
  fill_qty_ = value;
}

// optional uint32 cancel_qty = 6 [default = 0];
inline bool SimpleOrder::has_cancel_qty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SimpleOrder::set_has_cancel_qty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SimpleOrder::clear_has_cancel_qty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SimpleOrder::clear_cancel_qty() {
  cancel_qty_ = 0u;
  clear_has_cancel_qty();
}
inline ::google::protobuf::uint32 SimpleOrder::cancel_qty() const {
  return cancel_qty_;
}
inline void SimpleOrder::set_cancel_qty(::google::protobuf::uint32 value) {
  set_has_cancel_qty();
  cancel_qty_ = value;
}

// optional .IOC ioc = 7 [default = NONE];
inline bool SimpleOrder::has_ioc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SimpleOrder::set_has_ioc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SimpleOrder::clear_has_ioc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SimpleOrder::clear_ioc() {
  ioc_ = 0;
  clear_has_ioc();
}
inline ::IOC SimpleOrder::ioc() const {
  return static_cast< ::IOC >(ioc_);
}
inline void SimpleOrder::set_ioc(::IOC value) {
  assert(::IOC_IsValid(value));
  set_has_ioc();
  ioc_ = value;
}

// -------------------------------------------------------------------

// TwoSideOrder_OneSideQuote

// optional .OpenClose open_close = 1 [default = OPEN];
inline bool TwoSideOrder_OneSideQuote::has_open_close() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TwoSideOrder_OneSideQuote::set_has_open_close() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TwoSideOrder_OneSideQuote::clear_has_open_close() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TwoSideOrder_OneSideQuote::clear_open_close() {
  open_close_ = 0;
  clear_has_open_close();
}
inline ::OpenClose TwoSideOrder_OneSideQuote::open_close() const {
  return static_cast< ::OpenClose >(open_close_);
}
inline void TwoSideOrder_OneSideQuote::set_open_close(::OpenClose value) {
  assert(::OpenClose_IsValid(value));
  set_has_open_close();
  open_close_ = value;
}

// required uint32 quantity = 2;
inline bool TwoSideOrder_OneSideQuote::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TwoSideOrder_OneSideQuote::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TwoSideOrder_OneSideQuote::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TwoSideOrder_OneSideQuote::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 TwoSideOrder_OneSideQuote::quantity() const {
  return quantity_;
}
inline void TwoSideOrder_OneSideQuote::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
}

// required .RationalNumber price = 3;
inline bool TwoSideOrder_OneSideQuote::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TwoSideOrder_OneSideQuote::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TwoSideOrder_OneSideQuote::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TwoSideOrder_OneSideQuote::clear_price() {
  if (price_ != NULL) price_->::RationalNumber::Clear();
  clear_has_price();
}
inline const ::RationalNumber& TwoSideOrder_OneSideQuote::price() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return price_ != NULL ? *price_ : *default_instance().price_;
#else
  return price_ != NULL ? *price_ : *default_instance_->price_;
#endif
}
inline ::RationalNumber* TwoSideOrder_OneSideQuote::mutable_price() {
  set_has_price();
  if (price_ == NULL) price_ = new ::RationalNumber;
  return price_;
}
inline ::RationalNumber* TwoSideOrder_OneSideQuote::release_price() {
  clear_has_price();
  ::RationalNumber* temp = price_;
  price_ = NULL;
  return temp;
}
inline void TwoSideOrder_OneSideQuote::set_allocated_price(::RationalNumber* price) {
  delete price_;
  price_ = price;
  if (price) {
    set_has_price();
  } else {
    clear_has_price();
  }
}

// optional uint32 fill_qty = 4;
inline bool TwoSideOrder_OneSideQuote::has_fill_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TwoSideOrder_OneSideQuote::set_has_fill_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TwoSideOrder_OneSideQuote::clear_has_fill_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TwoSideOrder_OneSideQuote::clear_fill_qty() {
  fill_qty_ = 0u;
  clear_has_fill_qty();
}
inline ::google::protobuf::uint32 TwoSideOrder_OneSideQuote::fill_qty() const {
  return fill_qty_;
}
inline void TwoSideOrder_OneSideQuote::set_fill_qty(::google::protobuf::uint32 value) {
  set_has_fill_qty();
  fill_qty_ = value;
}

// optional uint32 cancel_qty = 5;
inline bool TwoSideOrder_OneSideQuote::has_cancel_qty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TwoSideOrder_OneSideQuote::set_has_cancel_qty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TwoSideOrder_OneSideQuote::clear_has_cancel_qty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TwoSideOrder_OneSideQuote::clear_cancel_qty() {
  cancel_qty_ = 0u;
  clear_has_cancel_qty();
}
inline ::google::protobuf::uint32 TwoSideOrder_OneSideQuote::cancel_qty() const {
  return cancel_qty_;
}
inline void TwoSideOrder_OneSideQuote::set_cancel_qty(::google::protobuf::uint32 value) {
  set_has_cancel_qty();
  cancel_qty_ = value;
}

// -------------------------------------------------------------------

// TwoSideOrder

// optional .TwoSideOrder.OneSideQuote bid_quote = 2;
inline bool TwoSideOrder::has_bid_quote() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TwoSideOrder::set_has_bid_quote() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TwoSideOrder::clear_has_bid_quote() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TwoSideOrder::clear_bid_quote() {
  if (bid_quote_ != NULL) bid_quote_->::TwoSideOrder_OneSideQuote::Clear();
  clear_has_bid_quote();
}
inline const ::TwoSideOrder_OneSideQuote& TwoSideOrder::bid_quote() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bid_quote_ != NULL ? *bid_quote_ : *default_instance().bid_quote_;
#else
  return bid_quote_ != NULL ? *bid_quote_ : *default_instance_->bid_quote_;
#endif
}
inline ::TwoSideOrder_OneSideQuote* TwoSideOrder::mutable_bid_quote() {
  set_has_bid_quote();
  if (bid_quote_ == NULL) bid_quote_ = new ::TwoSideOrder_OneSideQuote;
  return bid_quote_;
}
inline ::TwoSideOrder_OneSideQuote* TwoSideOrder::release_bid_quote() {
  clear_has_bid_quote();
  ::TwoSideOrder_OneSideQuote* temp = bid_quote_;
  bid_quote_ = NULL;
  return temp;
}
inline void TwoSideOrder::set_allocated_bid_quote(::TwoSideOrder_OneSideQuote* bid_quote) {
  delete bid_quote_;
  bid_quote_ = bid_quote;
  if (bid_quote) {
    set_has_bid_quote();
  } else {
    clear_has_bid_quote();
  }
}

// optional .TwoSideOrder.OneSideQuote ask_quote = 3;
inline bool TwoSideOrder::has_ask_quote() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TwoSideOrder::set_has_ask_quote() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TwoSideOrder::clear_has_ask_quote() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TwoSideOrder::clear_ask_quote() {
  if (ask_quote_ != NULL) ask_quote_->::TwoSideOrder_OneSideQuote::Clear();
  clear_has_ask_quote();
}
inline const ::TwoSideOrder_OneSideQuote& TwoSideOrder::ask_quote() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ask_quote_ != NULL ? *ask_quote_ : *default_instance().ask_quote_;
#else
  return ask_quote_ != NULL ? *ask_quote_ : *default_instance_->ask_quote_;
#endif
}
inline ::TwoSideOrder_OneSideQuote* TwoSideOrder::mutable_ask_quote() {
  set_has_ask_quote();
  if (ask_quote_ == NULL) ask_quote_ = new ::TwoSideOrder_OneSideQuote;
  return ask_quote_;
}
inline ::TwoSideOrder_OneSideQuote* TwoSideOrder::release_ask_quote() {
  clear_has_ask_quote();
  ::TwoSideOrder_OneSideQuote* temp = ask_quote_;
  ask_quote_ = NULL;
  return temp;
}
inline void TwoSideOrder::set_allocated_ask_quote(::TwoSideOrder_OneSideQuote* ask_quote) {
  delete ask_quote_;
  ask_quote_ = ask_quote;
  if (ask_quote) {
    set_has_ask_quote();
  } else {
    clear_has_ask_quote();
  }
}

// -------------------------------------------------------------------

// OrderHeader

// optional .Time timestamp = 1;
inline bool OrderHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::Time::Clear();
  clear_has_timestamp();
}
inline const ::Time& OrderHeader::timestamp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return timestamp_ != NULL ? *timestamp_ : *default_instance().timestamp_;
#else
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
#endif
}
inline ::Time* OrderHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::Time;
  return timestamp_;
}
inline ::Time* OrderHeader::release_timestamp() {
  clear_has_timestamp();
  ::Time* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void OrderHeader::set_allocated_timestamp(::Time* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional uint32 user_id = 2 [default = 0];
inline bool OrderHeader::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderHeader::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderHeader::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderHeader::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 OrderHeader::user_id() const {
  return user_id_;
}
inline void OrderHeader::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional uint32 user_ref = 3 [default = 0];
inline bool OrderHeader::has_user_ref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderHeader::set_has_user_ref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderHeader::clear_has_user_ref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderHeader::clear_user_ref() {
  user_ref_ = 0u;
  clear_has_user_ref();
}
inline ::google::protobuf::uint32 OrderHeader::user_ref() const {
  return user_ref_;
}
inline void OrderHeader::set_user_ref(::google::protobuf::uint32 value) {
  set_has_user_ref();
  user_ref_ = value;
}

// optional uint32 process_id = 4 [default = 0];
inline bool OrderHeader::has_process_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderHeader::set_has_process_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderHeader::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderHeader::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 OrderHeader::process_id() const {
  return process_id_;
}
inline void OrderHeader::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
}

// optional uint32 ecp_oid = 5 [default = 0];
inline bool OrderHeader::has_ecp_oid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderHeader::set_has_ecp_oid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderHeader::clear_has_ecp_oid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderHeader::clear_ecp_oid() {
  ecp_oid_ = 0u;
  clear_has_ecp_oid();
}
inline ::google::protobuf::uint32 OrderHeader::ecp_oid() const {
  return ecp_oid_;
}
inline void OrderHeader::set_ecp_oid(::google::protobuf::uint32 value) {
  set_has_ecp_oid();
  ecp_oid_ = value;
}

// optional uint32 seq_id = 6 [default = 0];
inline bool OrderHeader::has_seq_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderHeader::set_has_seq_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderHeader::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderHeader::clear_seq_id() {
  seq_id_ = 0u;
  clear_has_seq_id();
}
inline ::google::protobuf::uint32 OrderHeader::seq_id() const {
  return seq_id_;
}
inline void OrderHeader::set_seq_id(::google::protobuf::uint32 value) {
  set_has_seq_id();
  seq_id_ = value;
}

// optional .OrderHeader.OrderStatus status = 7 [default = NO_REPLY];
inline bool OrderHeader::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderHeader::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderHeader::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderHeader::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::OrderHeader_OrderStatus OrderHeader::status() const {
  return static_cast< ::OrderHeader_OrderStatus >(status_);
}
inline void OrderHeader::set_status(::OrderHeader_OrderStatus value) {
  assert(::OrderHeader_OrderStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 contract_id = 8;
inline bool OrderHeader::has_contract_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderHeader::set_has_contract_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderHeader::clear_has_contract_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderHeader::clear_contract_id() {
  contract_id_ = 0;
  clear_has_contract_id();
}
inline ::google::protobuf::int32 OrderHeader::contract_id() const {
  return contract_id_;
}
inline void OrderHeader::set_contract_id(::google::protobuf::int32 value) {
  set_has_contract_id();
  contract_id_ = value;
}

// optional string remark = 9;
inline bool OrderHeader::has_remark() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderHeader::set_has_remark() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderHeader::clear_has_remark() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderHeader::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& OrderHeader::remark() const {
  return *remark_;
}
inline void OrderHeader::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void OrderHeader::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void OrderHeader::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderHeader::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* OrderHeader::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderHeader::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string quote_ref = 10;
inline bool OrderHeader::has_quote_ref() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderHeader::set_has_quote_ref() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderHeader::clear_has_quote_ref() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderHeader::clear_quote_ref() {
  if (quote_ref_ != &::google::protobuf::internal::kEmptyString) {
    quote_ref_->clear();
  }
  clear_has_quote_ref();
}
inline const ::std::string& OrderHeader::quote_ref() const {
  return *quote_ref_;
}
inline void OrderHeader::set_quote_ref(const ::std::string& value) {
  set_has_quote_ref();
  if (quote_ref_ == &::google::protobuf::internal::kEmptyString) {
    quote_ref_ = new ::std::string;
  }
  quote_ref_->assign(value);
}
inline void OrderHeader::set_quote_ref(const char* value) {
  set_has_quote_ref();
  if (quote_ref_ == &::google::protobuf::internal::kEmptyString) {
    quote_ref_ = new ::std::string;
  }
  quote_ref_->assign(value);
}
inline void OrderHeader::set_quote_ref(const char* value, size_t size) {
  set_has_quote_ref();
  if (quote_ref_ == &::google::protobuf::internal::kEmptyString) {
    quote_ref_ = new ::std::string;
  }
  quote_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderHeader::mutable_quote_ref() {
  set_has_quote_ref();
  if (quote_ref_ == &::google::protobuf::internal::kEmptyString) {
    quote_ref_ = new ::std::string;
  }
  return quote_ref_;
}
inline ::std::string* OrderHeader::release_quote_ref() {
  clear_has_quote_ref();
  if (quote_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quote_ref_;
    quote_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderHeader::set_allocated_quote_ref(::std::string* quote_ref) {
  if (quote_ref_ != &::google::protobuf::internal::kEmptyString) {
    delete quote_ref_;
  }
  if (quote_ref) {
    set_has_quote_ref();
    quote_ref_ = quote_ref;
  } else {
    clear_has_quote_ref();
    quote_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderRequest

// required .OrderHeader order_header = 1;
inline bool OrderRequest::has_order_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderRequest::set_has_order_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderRequest::clear_has_order_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderRequest::clear_order_header() {
  if (order_header_ != NULL) order_header_->::OrderHeader::Clear();
  clear_has_order_header();
}
inline const ::OrderHeader& OrderRequest::order_header() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_header_ != NULL ? *order_header_ : *default_instance().order_header_;
#else
  return order_header_ != NULL ? *order_header_ : *default_instance_->order_header_;
#endif
}
inline ::OrderHeader* OrderRequest::mutable_order_header() {
  set_has_order_header();
  if (order_header_ == NULL) order_header_ = new ::OrderHeader;
  return order_header_;
}
inline ::OrderHeader* OrderRequest::release_order_header() {
  clear_has_order_header();
  ::OrderHeader* temp = order_header_;
  order_header_ = NULL;
  return temp;
}
inline void OrderRequest::set_allocated_order_header(::OrderHeader* order_header) {
  delete order_header_;
  order_header_ = order_header;
  if (order_header) {
    set_has_order_header();
  } else {
    clear_has_order_header();
  }
}

// optional .OrderInfo order_info = 2;
inline bool OrderRequest::has_order_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderRequest::set_has_order_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderRequest::clear_has_order_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderRequest::clear_order_info() {
  if (order_info_ != NULL) order_info_->::OrderInfo::Clear();
  clear_has_order_info();
}
inline const ::OrderInfo& OrderRequest::order_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_info_ != NULL ? *order_info_ : *default_instance().order_info_;
#else
  return order_info_ != NULL ? *order_info_ : *default_instance_->order_info_;
#endif
}
inline ::OrderInfo* OrderRequest::mutable_order_info() {
  set_has_order_info();
  if (order_info_ == NULL) order_info_ = new ::OrderInfo;
  return order_info_;
}
inline ::OrderInfo* OrderRequest::release_order_info() {
  clear_has_order_info();
  ::OrderInfo* temp = order_info_;
  order_info_ = NULL;
  return temp;
}
inline void OrderRequest::set_allocated_order_info(::OrderInfo* order_info) {
  delete order_info_;
  order_info_ = order_info;
  if (order_info) {
    set_has_order_info();
  } else {
    clear_has_order_info();
  }
}

// optional bool cancel_on_disconnect = 3 [default = true];
inline bool OrderRequest::has_cancel_on_disconnect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderRequest::set_has_cancel_on_disconnect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderRequest::clear_has_cancel_on_disconnect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderRequest::clear_cancel_on_disconnect() {
  cancel_on_disconnect_ = true;
  clear_has_cancel_on_disconnect();
}
inline bool OrderRequest::cancel_on_disconnect() const {
  return cancel_on_disconnect_;
}
inline void OrderRequest::set_cancel_on_disconnect(bool value) {
  set_has_cancel_on_disconnect();
  cancel_on_disconnect_ = value;
}

// optional int32 time_out = 4 [default = -1];
inline bool OrderRequest::has_time_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderRequest::set_has_time_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderRequest::clear_has_time_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderRequest::clear_time_out() {
  time_out_ = -1;
  clear_has_time_out();
}
inline ::google::protobuf::int32 OrderRequest::time_out() const {
  return time_out_;
}
inline void OrderRequest::set_time_out(::google::protobuf::int32 value) {
  set_has_time_out();
  time_out_ = value;
}

// -------------------------------------------------------------------

// OrderRequestAck

// optional .ReturnCode return_code = 1;
inline bool OrderRequestAck::has_return_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderRequestAck::set_has_return_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderRequestAck::clear_has_return_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderRequestAck::clear_return_code() {
  if (return_code_ != NULL) return_code_->::ReturnCode::Clear();
  clear_has_return_code();
}
inline const ::ReturnCode& OrderRequestAck::return_code() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return return_code_ != NULL ? *return_code_ : *default_instance().return_code_;
#else
  return return_code_ != NULL ? *return_code_ : *default_instance_->return_code_;
#endif
}
inline ::ReturnCode* OrderRequestAck::mutable_return_code() {
  set_has_return_code();
  if (return_code_ == NULL) return_code_ = new ::ReturnCode;
  return return_code_;
}
inline ::ReturnCode* OrderRequestAck::release_return_code() {
  clear_has_return_code();
  ::ReturnCode* temp = return_code_;
  return_code_ = NULL;
  return temp;
}
inline void OrderRequestAck::set_allocated_return_code(::ReturnCode* return_code) {
  delete return_code_;
  return_code_ = return_code;
  if (return_code) {
    set_has_return_code();
  } else {
    clear_has_return_code();
  }
}

// required .OrderHeader order_header = 2;
inline bool OrderRequestAck::has_order_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderRequestAck::set_has_order_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderRequestAck::clear_has_order_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderRequestAck::clear_order_header() {
  if (order_header_ != NULL) order_header_->::OrderHeader::Clear();
  clear_has_order_header();
}
inline const ::OrderHeader& OrderRequestAck::order_header() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_header_ != NULL ? *order_header_ : *default_instance().order_header_;
#else
  return order_header_ != NULL ? *order_header_ : *default_instance_->order_header_;
#endif
}
inline ::OrderHeader* OrderRequestAck::mutable_order_header() {
  set_has_order_header();
  if (order_header_ == NULL) order_header_ = new ::OrderHeader;
  return order_header_;
}
inline ::OrderHeader* OrderRequestAck::release_order_header() {
  clear_has_order_header();
  ::OrderHeader* temp = order_header_;
  order_header_ = NULL;
  return temp;
}
inline void OrderRequestAck::set_allocated_order_header(::OrderHeader* order_header) {
  delete order_header_;
  order_header_ = order_header;
  if (order_header) {
    set_has_order_header();
  } else {
    clear_has_order_header();
  }
}

// required .OrderRequestAck.Type request_type = 3;
inline bool OrderRequestAck::has_request_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderRequestAck::set_has_request_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderRequestAck::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderRequestAck::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::OrderRequestAck_Type OrderRequestAck::request_type() const {
  return static_cast< ::OrderRequestAck_Type >(request_type_);
}
inline void OrderRequestAck::set_request_type(::OrderRequestAck_Type value) {
  assert(::OrderRequestAck_Type_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// -------------------------------------------------------------------

// OrderAck

// required .OrderHeader order_header = 1;
inline bool OrderAck::has_order_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderAck::set_has_order_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderAck::clear_has_order_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderAck::clear_order_header() {
  if (order_header_ != NULL) order_header_->::OrderHeader::Clear();
  clear_has_order_header();
}
inline const ::OrderHeader& OrderAck::order_header() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_header_ != NULL ? *order_header_ : *default_instance().order_header_;
#else
  return order_header_ != NULL ? *order_header_ : *default_instance_->order_header_;
#endif
}
inline ::OrderHeader* OrderAck::mutable_order_header() {
  set_has_order_header();
  if (order_header_ == NULL) order_header_ = new ::OrderHeader;
  return order_header_;
}
inline ::OrderHeader* OrderAck::release_order_header() {
  clear_has_order_header();
  ::OrderHeader* temp = order_header_;
  order_header_ = NULL;
  return temp;
}
inline void OrderAck::set_allocated_order_header(::OrderHeader* order_header) {
  delete order_header_;
  order_header_ = order_header;
  if (order_header) {
    set_has_order_header();
  } else {
    clear_has_order_header();
  }
}

// required .OrderInfo order_info = 2;
inline bool OrderAck::has_order_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderAck::set_has_order_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderAck::clear_has_order_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderAck::clear_order_info() {
  if (order_info_ != NULL) order_info_->::OrderInfo::Clear();
  clear_has_order_info();
}
inline const ::OrderInfo& OrderAck::order_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_info_ != NULL ? *order_info_ : *default_instance().order_info_;
#else
  return order_info_ != NULL ? *order_info_ : *default_instance_->order_info_;
#endif
}
inline ::OrderInfo* OrderAck::mutable_order_info() {
  set_has_order_info();
  if (order_info_ == NULL) order_info_ = new ::OrderInfo;
  return order_info_;
}
inline ::OrderInfo* OrderAck::release_order_info() {
  clear_has_order_info();
  ::OrderInfo* temp = order_info_;
  order_info_ = NULL;
  return temp;
}
inline void OrderAck::set_allocated_order_info(::OrderInfo* order_info) {
  delete order_info_;
  order_info_ = order_info;
  if (order_info) {
    set_has_order_info();
  } else {
    clear_has_order_info();
  }
}

// -------------------------------------------------------------------

// OrderFill

// required .Time exec_time = 1;
inline bool OrderFill::has_exec_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderFill::set_has_exec_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderFill::clear_has_exec_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderFill::clear_exec_time() {
  if (exec_time_ != NULL) exec_time_->::Time::Clear();
  clear_has_exec_time();
}
inline const ::Time& OrderFill::exec_time() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return exec_time_ != NULL ? *exec_time_ : *default_instance().exec_time_;
#else
  return exec_time_ != NULL ? *exec_time_ : *default_instance_->exec_time_;
#endif
}
inline ::Time* OrderFill::mutable_exec_time() {
  set_has_exec_time();
  if (exec_time_ == NULL) exec_time_ = new ::Time;
  return exec_time_;
}
inline ::Time* OrderFill::release_exec_time() {
  clear_has_exec_time();
  ::Time* temp = exec_time_;
  exec_time_ = NULL;
  return temp;
}
inline void OrderFill::set_allocated_exec_time(::Time* exec_time) {
  delete exec_time_;
  exec_time_ = exec_time;
  if (exec_time) {
    set_has_exec_time();
  } else {
    clear_has_exec_time();
  }
}

// required string exec_id = 2;
inline bool OrderFill::has_exec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderFill::set_has_exec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderFill::clear_has_exec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderFill::clear_exec_id() {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    exec_id_->clear();
  }
  clear_has_exec_id();
}
inline const ::std::string& OrderFill::exec_id() const {
  return *exec_id_;
}
inline void OrderFill::set_exec_id(const ::std::string& value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void OrderFill::set_exec_id(const char* value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void OrderFill::set_exec_id(const char* value, size_t size) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFill::mutable_exec_id() {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  return exec_id_;
}
inline ::std::string* OrderFill::release_exec_id() {
  clear_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_id_;
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFill::set_allocated_exec_id(::std::string* exec_id) {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    delete exec_id_;
  }
  if (exec_id) {
    set_has_exec_id();
    exec_id_ = exec_id;
  } else {
    clear_has_exec_id();
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .OpenClose open_close = 3 [default = OPEN];
inline bool OrderFill::has_open_close() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderFill::set_has_open_close() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderFill::clear_has_open_close() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderFill::clear_open_close() {
  open_close_ = 0;
  clear_has_open_close();
}
inline ::OpenClose OrderFill::open_close() const {
  return static_cast< ::OpenClose >(open_close_);
}
inline void OrderFill::set_open_close(::OpenClose value) {
  assert(::OpenClose_IsValid(value));
  set_has_open_close();
  open_close_ = value;
}

// required .BuySell buy_sell = 4;
inline bool OrderFill::has_buy_sell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderFill::set_has_buy_sell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderFill::clear_has_buy_sell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderFill::clear_buy_sell() {
  buy_sell_ = 0;
  clear_has_buy_sell();
}
inline ::BuySell OrderFill::buy_sell() const {
  return static_cast< ::BuySell >(buy_sell_);
}
inline void OrderFill::set_buy_sell(::BuySell value) {
  assert(::BuySell_IsValid(value));
  set_has_buy_sell();
  buy_sell_ = value;
}

// required uint32 quantity = 5;
inline bool OrderFill::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderFill::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderFill::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderFill::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 OrderFill::quantity() const {
  return quantity_;
}
inline void OrderFill::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
}

// required double price = 6;
inline bool OrderFill::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderFill::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderFill::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderFill::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double OrderFill::price() const {
  return price_;
}
inline void OrderFill::set_price(double value) {
  set_has_price();
  price_ = value;
}

// optional .Source source = 7 [default = EXCHANGE];
inline bool OrderFill::has_source() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderFill::set_has_source() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderFill::clear_has_source() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderFill::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::Source OrderFill::source() const {
  return static_cast< ::Source >(source_);
}
inline void OrderFill::set_source(::Source value) {
  assert(::Source_IsValid(value));
  set_has_source();
  source_ = value;
}

// optional .Mode mode = 8 [default = NORMAL];
inline bool OrderFill::has_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderFill::set_has_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderFill::clear_has_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderFill::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::Mode OrderFill::mode() const {
  return static_cast< ::Mode >(mode_);
}
inline void OrderFill::set_mode(::Mode value) {
  assert(::Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// required .OrderHeader order_header = 9;
inline bool OrderFill::has_order_header() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderFill::set_has_order_header() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderFill::clear_has_order_header() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderFill::clear_order_header() {
  if (order_header_ != NULL) order_header_->::OrderHeader::Clear();
  clear_has_order_header();
}
inline const ::OrderHeader& OrderFill::order_header() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_header_ != NULL ? *order_header_ : *default_instance().order_header_;
#else
  return order_header_ != NULL ? *order_header_ : *default_instance_->order_header_;
#endif
}
inline ::OrderHeader* OrderFill::mutable_order_header() {
  set_has_order_header();
  if (order_header_ == NULL) order_header_ = new ::OrderHeader;
  return order_header_;
}
inline ::OrderHeader* OrderFill::release_order_header() {
  clear_has_order_header();
  ::OrderHeader* temp = order_header_;
  order_header_ = NULL;
  return temp;
}
inline void OrderFill::set_allocated_order_header(::OrderHeader* order_header) {
  delete order_header_;
  order_header_ = order_header;
  if (order_header) {
    set_has_order_header();
  } else {
    clear_has_order_header();
  }
}

// required uint32 clearing_date = 10;
inline bool OrderFill::has_clearing_date() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderFill::set_has_clearing_date() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderFill::clear_has_clearing_date() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderFill::clear_clearing_date() {
  clearing_date_ = 0u;
  clear_has_clearing_date();
}
inline ::google::protobuf::uint32 OrderFill::clearing_date() const {
  return clearing_date_;
}
inline void OrderFill::set_clearing_date(::google::protobuf::uint32 value) {
  set_has_clearing_date();
  clearing_date_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TLib_2fep_2ftsystem_5fecp_5fmsg_2eproto__INCLUDED
